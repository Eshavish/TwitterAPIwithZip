var MongoClient=require("mongodb").MongoClient,
	fs=require("fs"),
	nodeXLS=require("excel-export"),
	MetaInspector=require("node-metainspector"),
	HASHTABLE=require('jshashtable'),
	EXTEND=require('util')._extend,
	$=require("cheerio"),
	MOMENT=require("moment"),
	REQUEST=require("request"),
	OGR2OGR=require("ogr2ogr"),
	MERCATOR=require("sphericalmercator"),
	MERC=new MERCATOR({size:256}),
	CANVAS=require("canvas"),
	HEATMAP=require("heatmap"),
	NODEMAILER=require("nodemailer"),
	TRANSPORTER=NODEMAILER.createTransport({
		service:"gmail",
		auth:{  //NEED TO USE XAUTH2.0 TO LOGIN GMAIL. SEE http://stackoverflow.com/questions/19877246/nodemailer-with-gmail-and-nodejs
			user:"hdmasdsu@gmail.com",
			pass:"hdma@SDSU"
		}
	}),
	//HEATMAP=require("heatmap"),
	client=null,
	og=require("open-graph"),
	logger=require("../config/logger.js"),
	HASHTABLE=require('jshashtable'),
	cachedOpengraph=new HASHTABLE(),
	CRAWLER=require("crawler"),
	crawlerEngine=new CRAWLER({
		maxConnection:10,
		callback: function(err, result, $){

		}
	});



var API={
	//mongodb
	mongodb:{
		/**
		 * Connect Mongo
		 * @param {String} url
		 * @param {Number} port
		 * @param {String} dbname
		 * @param {callback} callback function. return db object
		 */
		connect: function(url, dbname, callback){
			url=url || "";
			dbname=dbname || ""

			var mongodb=this.cacheDB;

			if(url!='' && dbname!=""){
				var path="mongodb://"+url+"/"+dbname;

				if(mongodb[url] && mongodb[url][dbname]){
					if(callback){
						callback(mongodb[url][dbname]);


						logger.info('*************************************************************************')
						logger.info("mongodb connected (existed): "+ path)
					}
				}else{
					MongoClient.connect(path, function(error, db){
						if(error) throw error

						if(!mongodb[url]){
							mongodb[url]={}
						}

						if(!mongodb[url][dbname]){
							mongodb[url][dbname]=db
						}



						if(callback){
							callback(mongodb[url][dbname])
						}

						logger.info('*************************************************************************')
						logger.info("mongodb connected (new): "+ path)
					})
				}
			}else{

				logger.error("[ERROR] hdma.utilities.connectMongo: no URL, PORT, and DBNAME");
				return;
			}
		},

		//cached database connection to increase the performance
		cacheDB:{},

		/**
		 * query collection in a mongodb
		 * @param (mongodb) mongodb object
		 * @param {String} collectionName: collection name
		 * @param {Object} query
		 * @param {Object} options
		 * @param {callback} callback function. return error and results array
		 */
		query: function(db, collectionName, query, options, callback){
			logger.info('*************************************************************************')
			logger.info('querying MongoDb. collection=' + collectionName)
			var startQuery=new Date();
			logger.info('query at= '+startQuery)
			logger.info('query params=')
            //CHRIS: I changed this to only print out the first 100 characters of the query
            //because I am doing some queries with a list of many IDs, which take a while
            //to print to the command line...
			//Calvin: extend to 500 characters..need to see some parameters
			logger.info(JSON.stringify(query).substring(0, 500));
			logger.info('query options=')
			logger.info(options)

			var err={
				"a":"[ERROR] hdma.mongodb.query: no db, collection,or query object.",
				"b":"[ERROR] hdma.mongodb.query: no collection in db."
			}

			if(!options){options={}}
			options.fields=options.fields || null;
			options.sort=options.sort || null;
			options.limit=options.limit || 1000;
			options.batchSize=parseInt(options.batchSize) || null;
			options.onEachTweet=options.onEachTweet || null

			if(db && collectionName && collectionName!='' && query){
				var col=db.collection(collectionName)

				if(col){
					var cursor=col.find(query, options);

					//explain cursor
					cursor.explain(function(err, result){
						logger.info('*************************************************************************')
						logger.info('Index:')
						if(result){
							var out={};
							["cursor","isMultiKey","n","nscannedObjects","nscanned","nscannedObjectsAllPlans","nscannedAllPlans", "scanAndOrder","indexOnly","nYields", "nChunkSkips", "millis"].forEach(function(k){
								if(result[k]){out[k]=result[k]}
							})
							logger.info(out)
						}
					})

					if(options.limit<=10000){
						/** directly convert to Array, but not good for large datasets
						col.find(query, options).toArray(function(error, results){
							if(error){
								logger.error("[ERROR] hdma.mongodb.query:" + error);
								if(callback){callback(error, null)}
								return;
							}else{
								logger.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s")
								if(callback){callback(null, results)}
							}
						});
						*/

						//on each
						var results=[], num=0;
						cursor.each(function(err, doc){
							if(err){
								logger.error("[ERROR] hdma.mongodb.query:" + err);
								if(callback){callback(err, null)}
								return;
							}

							process.nextTick(function(){
								if(doc){
										if(options.onEachTweet){
											var obj=options.onEachTweet(doc, num);
											if(obj&&obj!=null){
												results.push(obj)
											}
										}else{
											results.push(doc)
										}
										num++;

								}else{
									logger.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s")
									if(callback){callback(null, results)}
								}
							})
						})


					}else{
						logger.info("use Streaming to retrieve mongo data");
						var results=[],num=0;
						//options.explain=true;

						//if options.sort exists, it will decrease performance especially when query lots of datasets (more than 20000)
						//need to set options.sort=null
						//however, it can be improved by setting compound index (set index on two more field at the same time. such as keywords+created_at_local)

						/** streaming */
						var stream=cursor.stream();
						stream.on("error", function(err){logger.error("[ERROR] hdma.mongodb.query:" + err); if(callback){callback(err,null)}})
						stream.on("data", function(doc){
							process.nextTick(function(){
								if(options.onEachTweet){
									var obj=options.onEachTweet(doc, num);
									if(obj&&obj!=null){
										results.push(obj)
									}
								}else{
									results.push(doc)
								}
								num++;

								if(num%10000==0){
									console.log(num)
								}
							});

						})
						stream.on("close", function(){
							logger.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s");
							startQuery=new Date();
							if(callback){callback(null, results)}
							logger.info("ProcessTime= "+ (new Date()-startQuery)/1000+ "s");
						});

					}




				}else{
					logger.error(err["b"])
					if(callback){callback(err["b"], null)}
					return;
				}
			}else{
				logger.error(err["a"]);
				if(callback){
					callback(err["a"], null)
				}
			}
		},


		/**
		 * update collection
		 * @param (mongodb) mongodb object
		 * @param {String} collectionName: collection name
		 * @param {Object} selector
		 * @param {Object} params
		 * @param {Object} options
		 * @param {callback} callback function. return error and result
		 */
		update: function(db, collectionName, selector, params, options, callback){
			logger.info('*************************************************************************')
			logger.info('updating MongoDb. collection=' + collectionName)
			logger.info('update on= ')
			logger.info(selector)
			logger.info('where params=')
			logger.info(JSON.stringify(params));
			logger.info('query options=')
			logger.info(options)

			var collection=db.collection(collectionName, function(err, col){
				col.update(selector, params, options, function(e, result){
					if(callback){
						callback(e, result)
					}
				})
			});

		},



		/**
		 * count collection in a mongodb
		 * @param (mongodb) mongodb object
		 * @param {String} collectionName: collection name
		 * @param {Object} query
		 * @param {Object} options
		 * @param {callback} callback function. return error and count
		 */
		count: function(db, collectionName, query, options, callback){
			logger.info('*************************************************************************')
			logger.info('count MongoDb. collection=' + collectionName)
			var startQuery=new Date();
			logger.info('count at= '+startQuery)
			logger.info('count params=')
			logger.info(query)


			if(!options){options={}}
			//options.fields=options.fields || null;
			//options.sort=options.sort || null;
			//options.limit=options.limit || 1000;
			//options.batchSize=parseInt(options.batchSize) || null;

			if(db && collectionName && collectionName!='' && query){
				var col=db.collection(collectionName);

				col.find(query).count(callback)
			}
		}




	}, //end hdma.mongodb,


	//common
	common:{
		/**
		 *  check if user loggin by passport
		 */
		ensureAuthenticated:function(options){
			options=options || {};
			options.type=options.type || "twitter";

			return function(req, res, next){
				if(req.isAuthenticated()){
	 				next();
	 			}else{
	 				res.redirect("/hdma/auth/"+options.type+"?returnTo="+req.path);
	 			}
			}
 		},


		/**
		 *	parseFeatures
		 *	@param (Array) results
		 *	@param (String) geometryFieldName
		 *	@param (Object) options{
		 *		geomasking (Boolean): default is false
		 *		geomaskingRadius (Number): unit is meter. default is 0
		 *		hideProperties (Array): the properties would not like to show in the geojson
		 *  }
		 *  @return (Array) geojson feature array
		*/
		parseFeatures: function(results, geometryFieldName, options){
			if(!results || !geometryFieldName || geometryFieldName==''){logger.error("[ERROR] hdma.common.parseFeatures: no results, geometryFieldName."); return;}


			//options
			if(!options){options={}}
			options.geomasking=options.geomasking || false;
			options.geomaskingRadius=options.geomaskingRadius || 0;
			options.hideProperties=options.hideProperties || ["_id"]


			var features=[], feature, geo,
				radius=options.geomaskingRadius,
				hideProperties=options.hideProperties,
				that=this;

			//parse
			for(var i=0,length=results.length;i<length;i++){
				feature=results[i];
				geo=feature[geometryFieldName]

				feature={"type":"Feature","properties":feature, "geometry":{"type":"Point", "coordinates":[geo.coordinates[1], geo.coordinates[0]]}};

				//geomasking
				if(options.geomasking){
					feature["geomasked_geometry"]={"type":"Point", "coordinates":[that.geomasking(geo.coordinates[1],radius), that.geomasking(geo.coordinates[0],radius)]}
				}


				//delete properties
				for(var j=0,l=hideProperties.length;j<l;j++){
					delete feature.properties[hideProperties[j]]
				}


				features.push(feature);
			}

			return features
		},


		/**
		 *	geomasking
		 *	@param (Number) number
		 *	@param (Number) radius. the unit is meter
		 *  @return (Number) a random number within the radius
		*/
		geomasking: function(num, radius){
			var randomNumber=Math.floor(Math.random()*(radius+1))-radius;
			return (num + ((randomNumber/111000))).toFixed(7);
		},



		//write a file
		writeFile: function(filePathAndName, data, callback){
			//check if exist
			fs.exists(filePathAndName, function(exists){
				if(exists){
					//delete file
					fs.unlink(filePathAndName, function(err){
						write()
					})
				}else{
					write()
				}
			});

			function write(){
				//fs.writeFile(filePathAndName, data, function(err){
				fs.appendFile(filePathAndName, JSON.stringify(data, null, 4), function(err){
					if(callback){
						callback(err)
					}
				})
			}
		},


		//read a file
		readFile: function(filePathAndName, callback){
			fs.readFile(filePathAndName, function(err, data){
				if(callback){
					callback(err, data)
				}
			})
		},

		//export to xls
		exportXLS: function(dataArray, options){
			if(!dataArray || dataArray.length==0){logger.error("[ERROR] hdma.common.exportXLS: no dataArray"); return; }

			if(!options){options={}}
			options.stylesXmlFile='style/styles.xml'; //style file. we can design xls style first and make conf to read the style file.

			var conf={
				cols:[],
				rows:[],
				stylesXmlFile:options.stylesXmlFile
			};

			//read data
			var data;
			for(var i=0; i<dataArray.length; i++){
				data=dataArray[i];

				var rows=[]
				for (key in data){
					if(i==0){
						conf.cols.push({
							caption:key.toUpperCase(),
							type:typeof(data[key])
						});
					}

					rows.push(data[key]);
				}
				conf.rows.push(rows);
			}

			return nodeXLS.execute(conf);
		},

		//using node-metainspector to fetch webpage info
		fetch: function(req, res){
			var url=req.query.url || "",
				result={};

			if(url!=""){
				//if the url is not cache in the cachedOpengraph, then fetch it
				if(!cachedOpengraph.containsKey(url)){

					//process.nextTick(function(){
						client=new MetaInspector(decodeURIComponent(url), {});

						client.on("fetch", function(){
							result={
								title: parse(client, "title"), //(client.title&&typeof(client.title)=='function')?client.title():client.title,
								url: parse(client, "url"), //(client.url)?client.url:null,
								scheme: parse(client, "scheme"), //(client.schema)?client.scheme:null,
								host: parse(client, "host"), //(client.host)?client.host:null,
								rootUrl: parse(client, "rootUrl"), //(client.rootUrl)?client.rootUrl:null,
								//links: parse(client, "links"), //(client.links&&client.links())?client.links():null,
								author: parse(client, "author"), //(client.author&&typeof(client.author)=='function')?client.author():null,
								keywords: parse(client, "keywords"), //(client.keywords&&typeof(client.keywords)=='function')?client.keywords():null,
								metaDescription: parse(client, "metaDescription"), //(client.metaDescription&&typeof(client.metaDescription)=='function')?client.metaDescription():null,
								description: parse(client, "description"), //(client.description&&typeof(client.description)=='function')?client.description():null,
								images: parse(client, "images"), //(client.images&&typeof(client.images)=='function')?client.images():null,
								image: parse(client, "image"), //(client.image&&typeof(client.image)=='function')?client.image():null,
								//feeds: parse(client, "feeds"), //(client.feeds&&typeof(client.feeds)=='function')?client.feeds():null,
								ogtitle: parse(client, "ogtitle") //(client.ogtitle&&typeof(client.ogtitle)=='function')?client.ogtitle():null
							};

							//if the result contains strange characters >> replace with url
							result["description"]=(result["description"]&&result["description"].indexOf("ï¿½")!=-1)?result["url"]:result["description"];

							cachedOpengraph.put(client.url, result)

							//console.log(result)
							res.end(JSON.stringify(result));
						})

						client.on("error", function(err, response){
							res.end(JSON.stringify({error:err, response:response}))
						})

						client.fetch();


					//})

				}else{
					res.end(JSON.stringify(cachedOpengraph.get(url)))
					logger.info("********************************************************")
					logger.info(url +" is existed in the cachedOpengraph")
				}


			}else{
				res.end('NO URL!!');
			}


			//parse
			function parse(obj, elem){
				var output=null;

				if(obj&&obj[elem]){
					output=obj[elem];

					//cheerio object
					if(typeof(obj[elem])=='object'&&!(obj[elem] instanceof Array)){
						//use get() to get all elements and convert to array
						output=obj[elem].get()
					}

				}

				return output;
			}

		},


		//opengraph
		opengraph: function(req, res){
			var url=req.query.url || "";

			if(url!=""){
				og(url, function(err, meta){
					if(err){res.send(JSON.stringify(err)); return;}

					res.send(JSON.stringify(meta))
				})



			}else{
				res.send("NO URL!!");
			}
		},



		//get body html from a webpage
		getHtml: function(host, path, options, callback){
			if(!options){options={}}

			options.username=options.username || "";
			options.password=options.password || "";
			options.replaces=options.replaces || []; //["getTopics.py", "getTweets.py", "loading_bar.gif"];
			options.replacePath=options.replacePath || "";

			var http=require('http'),
				params={
					host:host,
					path:path
				},
				body="";

			if(options.username&&options.username!=""&&options.password&&options.password!=""){
				params["auth"]=options.username+":"+options.password;
			}

			var request=http.request(params, function(result){
				//console.log('STATUS: ' + result.statusCode);
				//console.log('HEADERS: ' + JSON.stringify(result.headers));
				result.setEncoding('utf8');
				result.on('data', function (chunk) {
					body+=chunk
				});
				result.on('end', function(){
					//replace file path
					options.replaces.map(function(v,i){
						body=body.replace(v, options.replacePath+v);
					});

					if(callback)(
						callback(body)
					)
				});
			});

			request.on('error', function(e) {
				console.log('problem with request: ' + e.message);
			});

			request.end();
		},



		//use crawler lib to crawl web content
		crawler: function(req, res){
			var url=decodeURIComponent(req.query.url) || null;

			if(url){
				crawlerEngine.queue({
					uri: url,
					callback: function(err, result, $){
						/** don't have time to figure out
						console.log(err)
						if(err){res.end(JSON.stringify(err)); return; }

						var urls=""
						$('a').each(function(i,v){
							urls+=$(v).attr("href")
						})
						res.end($("title").html())
						*/
					}
				})
			}


		},


		//login
		login: function(username, password, mongodb, callback){
			var crypto=require('crypto'),
				md5=crypto.createHash('md5');

			if(username&&username!=""&&password&&password!=""){
				//connect to user profile collection in mongodb to verify the username
				API.mongodb.query(mongodb, "userProfile", {"username": username}, null, function(err, results){
					var output={status:"error", msg:"Username or password is not correct."};

					if(err){
						output.msg=err
					}else{
						if(results&&results.length>0){
							var hash,
								profile=results[0]; //should be only one result (username)

							//hash password
							hash=md5.update(profile.password).digest('hex');

							if(password==hash){
								output={status:"ok", username:username, html:{download:""}, token:profile.token, groups:profile.groups, topics:profile.topics, note_geoviewer:profile.note_geoviewer, bookmarks:profile.bookmarks}
							}else{
								//incorrect password
								output.msg="The password does not match. Please check and try again."
							}
						}else{
							//no username
							output.msg="The username, "+ username+", does not match. Please check and try again."
						}
					}

					//callback
					if(callback){callback(output)}
				})
			}

		},


		//parse URL params
		parseURL: function(req){
			var params={},
				obj={
					topic:req.params.topic || req.query.topic || "all",
					keywords:req.query.keywords || null,
					texts:req.query.texts || null,
					cities:req.query.cities || null,
					excel:req.query.excel || false,
					startDate:req.query.startDate || null,
					endDate:req.query.endDate || null,
					gps:req.query.gps || false,
					source:req.query.source || "search",
					limit:req.query.limit || 1000,
					sort:req.query.sort || null,
					loc:req.query.loc || null,
					radius:req.query.radius || null,
					format:req.query.format || "json",
					jscallback:req.query.jscallback || null,
					url:req.query.url || null,
					groupBy: req.query.groupBy || "search_info.search_areas.0.name",
					mentions:req.query.mentions || null,  //without @
					hashtags:req.query.hashtags || null,  //without #
					removeRT:req.query.removeRT || 0,
					removeURL:req.query.removeURL || 0,
					hasMedia:req.query.hasMedia || false,
					media:req.query.media || null,
					retweeted_id:req.query.retweeted_id || null,
					removeDuplicate:req.query.removeDuplicate || false,
					batchSize:req.query.batchSize || null,
					isFilter:req.query.isFilter || false,
					token:req.query.token || null,
					machineLearning: req.query.machineLearning || false,
					bbox:req.query.bbox || null,
					polygon:req.query.polygon || null,
					searchArea:req.query.searchArea || null,
					searchRegion:req.query.searchRegion || null,
					canvasType: req.query.canvasType || null,  //HEATMAP OR POINT
					canvasWidth: req.query.canvasWidth || null,
					canvasHeight: req.query.canvasHeight || null,
					heatmapRadius: req.query.heatmapRadius || null
				},
				fields={"lang":1, "search_info":1, "entities":1, "text":1, "created_at":1, "created_at_local":1, "source":1, "user":1, "id":1, "_id":0, "coordinates":1, "retweeted_id":1, "is_valid":1, "geocoded":1};


			//params
			if(obj.topic!="all"){
				params["search_info.topics"]=obj.topic;
				if(obj.topic.indexOf("archive_")!=-1){obj.source="twitterArchive";}
				if(obj.topic.indexOf("streaming")!=-1){obj.source="streaming";}
			}
			if(obj.keywords){params["search_info.keywords"]=(obj.keywords.split(",").length==1)?obj.keywords.split(",")[0]: {"$in": obj.keywords.split(",")}}//.map(function(k){return new RegExp(k, "i")})}}
			if(obj.cities || obj.searchArea){
				if(obj.cities&&obj.cities!='none'){
					params["search_info.search_areas.name"]=(obj.cities.split(",").length==1)?obj.cities.split(",")[0]: {"$in":obj.cities.split(",")}
				}

				//search area
				if(obj.searchArea&&obj.searchArea!=""){
					obj.searchArea=obj.searchArea.toLowerCase();
					params["search_info.search_areas.name"]=((obj.searchArea=="sandiego")?"San Diego region":obj.searchArea)
				}
			}
			if(obj.searchRegion){
				params["search_region"]=obj.searchRegion

				//delete search_info.search_areas.name
				delete params["search_info.search_areas.name"]
			}
			if(obj.startDate || obj.endDate){
				var dateParam={}
				if(obj.startDate){dateParam["$gte"]= new Date(MOMENT(obj.startDate).format("YYYY-MM-DDT00:00:00+00:00"))}
				if(obj.endDate){dateParam["$lt"]=new Date(MOMENT(obj.endDate).format("YYYY-MM-DDT00:00:00+00:00"))}
				params["created_at_local"]=dateParam;
			}
			if(obj.format=='geojson'){obj.gps=true;}
			if(obj.gps){params["geo"]={"$exists":true}}
			if(obj.loc){
				params["coordinates.coordinates"]={};
				params["coordinates.coordinates"]["$near"]=obj.loc.split(',').map(function(v){return parseFloat(v)})
				if(radius&&!isNaN(obj.radius)){params["coordinates.coordinates"]["$maxDistance"]=parseFloat(obj.radius)}
			}
			if(obj.texts){
				//params['text']["$all"]= obj.texts.split(',').map(function(k){return new RegExp("[#@ ^/]"+k+" ", "gi")})
				params["$text"]={"$search":obj.texts.split(",").map(function(k){return "'"+k+"'"}).join(",")}

				if(obj.source=='search'){params['text']={"$all": obj.texts.split(',').map(function(k){return new RegExp("(^| |[#@ ^/])"+k+"(|\W| |$|.$)", "gi")})};  delete params["$text"]}
			}
			if((obj.removeRT!=0&&obj.removeRT!="false") || (obj.removeURL!="false"&&obj.removeURL!=0)){
				params["text"]={}

				if(obj.removeRT){
					switch(String(obj.removeRT)){
						case "1":
							//REMOVE ALL TWEET START WITH 'RT' >> keep personal comments
							params['text']['$nin']=[/^RT /];
						break;
						case "2":
							//REMOVE ALL TWEET START WITH 'RT' OR CONTAIN 'RT' >> remove rt and remove personal comments
							params['text']['$nin']=[/( |^)RT /];
						break;
					}
				}
				if(obj.removeURL){
					switch(String(obj.removeURL)){
						case "1":
							//REOMVE A TWEET WHICH ONLY CONTAINS ONE URL, NO OTHER COMMENTS
							params['text']['$in']=[/^(?!(http[^\s]*$))/]
						break;
						case "2":
							if(!params['text']['$all'] && !params['text']['$nin']){delete params['text']}
							//REMOVE A TWEET WHICH CONTAINS URL
							params["entities.urls.0"]={'$exists': false}
							params["entities.media.0"]={'$exists': false}
						break;
					}
				}

				//if(removeURL){
				//	params['text']['$nin']=(params['text']['$nin']&&params['text']['$nin'].length>0)?params['text']['$nin'].concat([/http/ig, /https/ig]):[/http/ig, /https/ig]
				//}
			}
			//if(removeURL){params["entities.urls.0"]={'$exists': false}}
			//if(removeRT){params["retweeted_id"]={'$exists': false}}
			if(obj.mentions){params['entities.user_mentions']=(obj.mentions.split(",").length==1)?obj.mentions.split(",")[0]: {"$all": obj.mentions.split(',').map(function(k){return new RegExp(k, "i")})}}
			if(obj.hashtags){params['entities.hashtags']=(obj.hashtags.split(",").length==1)?obj.hashtags.split(",")[0]: {"$all": obj.hashtags.split(',').map(function(k){return new RegExp(k, "i")})}}
			if(obj.url){params["entities.urls"]=obj.url}
			if(obj.media){params["entities.media"]=(obj.media.split(",").length==1)?obj.media.split(",")[0]: {"$in": obj.media.split(',').map(function(k){return new RegExp(k, "i")})}}
			if(obj.hasMedia){params["entities.media.0"]={"$exists":true}}
			if(obj.retweeted_id){params["retweeted_id"]=parseInt(obj.retweeted_id)}
			//machine learning
			if(obj.machineLearning){
				if(obj.topic=='flu' || obj.topic=="flu2"){
					params["is_valid"]=true
				}else{
					//obj.machineLearning=false
				}
			}


			//bbox
			if(obj.bbox&&obj.bbox!=""){
				obj.bbox=obj.bbox.split(",").map(function(v,i){return parseFloat(v)});

				if(obj.bbox.length%2==0){
					//bbox length==4 >> rectangel bbox
					if(obj.bbox.length==4){
						var sw=obj.bbox.slice(0,2),
							ne=obj.bbox.slice(2,4),
							nw=[sw[0],ne[1]],
							se=[ne[0],sw[1]];

						/** $box only suppport 2d index
						params["coordinates.coordinates"]={
							"$geoWithin":{"$box":[sw, ne]}
						}
						*/
						//use 2dphere index
						params["coordinates"]={
							"$geoWithin":{"$geometry":{
								"type":"Polygon",
								"coordinates":[[sw, nw, ne, se, sw]]
							}}
						}
					}else{
						//polygon bbox
						var coords=[];
						for(var i=0, len=obj.bbox.length; i<len-2; i+=2){
							coords.push([obj.bbox[i], obj.bbox[i+1]])
						}

						params["coordinates.coordinates"]={
							"$geoWithin":{"$polygon":coords}
						}
					}
				}

			}
			//polygon: lng1, lat1, lng2, lat2, lng3, lat3
			if(obj.polygon&&obj.polygon!=""){
				var polygons=[], num=0
				obj.polygon=obj.polygon.split(',');

				//parse polygon
				for(var i=0, len=obj.polygon.length; i<len; i+=2){
					polygons.push([parseFloat(obj.polygon[i]), parseFloat(obj.polygon[i+1])])
				}

				params["coordinates.coordinates"]={
					"$geoWithin":{
						"$polygon":polygons
					}
				}
			}



			//options
			var options={
				fields: fields
			}
			if(obj.sort){options["sort"]={}; options["sort"][obj.sort]=-1}
			if(obj.limit){options["limit"]=obj.limit}
			if(obj.batchSize){options["batchSize"]=obj.batchSize}


			return {
				params:params,
				getMongodbQueryParams: function(){
					return {params:params, options:options}
				},
				getValue:function(paramName){
					if(obj[paramName]){
						return (isNaN(obj[paramName]))?obj[paramName]:parseFloat(obj[paramName])
					}
				}
			}
		},


		//get host path
		getHostPath: function(req){
			var host=req.get('host');
			/**
			switch(host){
				case "vision.sdsu.edu:8080":
					host="hdma";
				break;
				case "52.26.133.89:8080":
					host="ec2";
				break;
			}
			*/

			return (host=="vision.sdsu.edu:8080")?"hdma":"ec2"
		},


		// Porter stemmer in Javascript. Few comments, but it's easy to follow against the rules in the original
		// paper, in
		//
		//  Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,
		//  no. 3, pp 130-137,
		//
		// see also http://www.tartarus.org/~martin/PorterStemmer

		// Release 1 be 'andargor', Jul 2004
		// Release 2 (substantially revised) by Christopher McKenzie, Aug 2009

		stemmer: function(w){
			var step2list = {
					"ational" : "ate",
					"tional" : "tion",
					"enci" : "ence",
					"anci" : "ance",
					"izer" : "ize",
					"bli" : "ble",
					"alli" : "al",
					"entli" : "ent",
					"eli" : "e",
					"ousli" : "ous",
					"ization" : "ize",
					"ation" : "ate",
					"ator" : "ate",
					"alism" : "al",
					"iveness" : "ive",
					"fulness" : "ful",
					"ousness" : "ous",
					"aliti" : "al",
					"iviti" : "ive",
					"biliti" : "ble",
					"logi" : "log"
				},

				step3list = {
					"icate" : "ic",
					"ative" : "",
					"alize" : "al",
					"iciti" : "ic",
					"ical" : "ic",
					"ful" : "",
					"ness" : ""
				},

				c = "[^aeiou]",          // consonant
				v = "[aeiouy]",          // vowel
				C = c + "[^aeiouy]*",    // consonant sequence
				V = v + "[aeiou]*",      // vowel sequence

				mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
				meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
				mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
				s_v = "^(" + C + ")?" + v;                   // vowel in stem


				var stem,
					suffix,
					firstch,
					re,
					re2,
					re3,
					re4,
					origword = w;

				if (w.length < 3) { return w; }

				firstch = w.substr(0,1);
				if (firstch == "y") {
					w = firstch.toUpperCase() + w.substr(1);
				}

				// Step 1a
				re = /^(.+?)(ss|i)es$/;
				re2 = /^(.+?)([^s])s$/;

				if (re.test(w)) { w = w.replace(re,"$1$2"); }
				else if (re2.test(w)) {	w = w.replace(re2,"$1$2"); }

				// Step 1b
				re = /^(.+?)eed$/;
				re2 = /^(.+?)(ed|ing)$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					re = new RegExp(mgr0);
					if (re.test(fp[1])) {
						re = /.$/;
						w = w.replace(re,"");
					}
				} else if (re2.test(w)) {
					var fp = re2.exec(w);
					stem = fp[1];
					re2 = new RegExp(s_v);
					if (re2.test(stem)) {
						w = stem;
						re2 = /(at|bl|iz)$/;
						re3 = new RegExp("([^aeiouylsz])\\1$");
						re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
						if (re2.test(w)) {	w = w + "e"; }
						else if (re3.test(w)) { re = /.$/; w = w.replace(re,""); }
						else if (re4.test(w)) { w = w + "e"; }
					}
				}

				// Step 1c
				re = /^(.+?)y$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					stem = fp[1];
					re = new RegExp(s_v);
					if (re.test(stem)) { w = stem + "i"; }
				}

				// Step 2
				re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					stem = fp[1];
					suffix = fp[2];
					re = new RegExp(mgr0);
					if (re.test(stem)) {
						w = stem + step2list[suffix];
					}
				}

				// Step 3
				re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					stem = fp[1];
					suffix = fp[2];
					re = new RegExp(mgr0);
					if (re.test(stem)) {
						w = stem + step3list[suffix];
					}
				}

				// Step 4
				re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
				re2 = /^(.+?)(s|t)(ion)$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					stem = fp[1];
					re = new RegExp(mgr1);
					if (re.test(stem)) {
						w = stem;
					}
				} else if (re2.test(w)) {
					var fp = re2.exec(w);
					stem = fp[1] + fp[2];
					re2 = new RegExp(mgr1);
					if (re2.test(stem)) {
						w = stem;
					}
				}

				// Step 5
				re = /^(.+?)e$/;
				if (re.test(w)) {
					var fp = re.exec(w);
					stem = fp[1];
					re = new RegExp(mgr1);
					re2 = new RegExp(meq1);
					re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
					if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
						w = fp[0];  //need to return the original word not the stem
					}
				}

				re = /ll$/;
				re2 = new RegExp(mgr1);
				if (re.test(w) && re2.test(w)) {
					re = /.$/;
					w = w.replace(re,"");
				}

				// and turn initial Y back to y

				if (firstch == "y") {
					w = firstch.toLowerCase() + w.substr(1);
				}

				return w;

		},


		//get api scripts
		getAPIScript: function(req){
			//api scripts
			var host=this.getHostPath(req),
				jsPath="/"+host+"/js/api/",
				scripts=[jsPath+"hdma.layer.js", jsPath+"hdma.util.js"];

			return scripts
		},

		//get text from html tag
		getTextFromHTMLTag: function(linkText, tag) {
			var reg=new RegExp("<"+tag+" [^>]+>([^<]+)<\/"+tag+">")
			return linkText.match(reg)[1];
		},

		//send mail
		sendMail: function(mailOptions, callback){
			if(!mailOptions){mailOptions={}}
			mailOptions.from=mailOptions.from || "hdmasdsu@gmail.com";
			mailOptions.to=mailOptions.to || "hdmasdsu@gmail.com";
			mailOptions.subject=mailOptions.subject || "test";
			mailOptions.text=mailOptions.text || "test only";
			mailOptions.html=mailOptions.html || "<b>test only</b>"

			TRANSPORTER.sendMail(mailOptions, function(err, info){
				if(callback){
					callback(err, info)
				}
			})
		},

		//get common folder path
		getCommonFolderPath: function(req, params){
			params=params || {}
			var host=API.common.getHostPath(req);

			params.hostPath=host;
			params.commonPath=host+"/common";
			params.jsPath=params.commonPath+"/js";
			params.cssPath=params.commonPath+"/css";

			return params;
		}


	}, //end hdma.common




	//hdma.data
	data:{
		//getTweet
		getTweet: function(req, res, mongodb, nodeOptions){
			if(!mongodb){res.end('hdma.data.getTweet: no mongodb'); return; }

			if(!nodeOptions){nodeOptions={}}
			nodeOptions.callback=nodeOptions.callback || null;
			nodeOptions.forEach=nodeOptions.forEach || null;
			nodeOptions.checkToken=nodeOptions.checkToken || false;

			var xlsStream="",distinctCache=new HASHTABLE();
			var params=API.common.parseURL(req),
				queryParams=params.getMongodbQueryParams(),
				query=queryParams.params,
				options=queryParams.options,
				removeDuplicate=params.getValue('removeDuplicate'),
				excel=params.getValue('excel'),
				keywords=params.getValue('keywords'),
				cities=params.getValue('cities'),
				source=params.getValue('source'),
				removeRT=params.getValue('removeRT'),
				removeURL=params.getValue('removeURL'),
				format=params.getValue('format'),
				jscallback=params.getValue('jscallback'),
				topic=params.getValue('topic'),
				limit=params.getValue('limit'),
				machineLearning=params.getValue('machineLearning'),
				token=params.getValue("token"),
				startDate=params.getValue('startDate'),
				endDate=params.getValue('endDate'),
				bbox=params.getValue('bbox')
				texts=params.getValue('texts'),
				searchArea=params.getValue('searchArea'),
				searchRegion=params.getValue('searchRegion'),
				canvasType=params.getValue('canvasType'),
				canvasHeight=params.getValue('canvasHeight'),
				canvasWidth=params.getValue('canvasWidth'),
				heatmapRadius=params.getValue('heatmapRadius')
				canvasObj=null;


			//file name for excel or png
			var filename="["+topic+"]"+((keywords)?keywords.split(",").join("_") :((texts)?texts.replace(/\s+/g,"_"):"allKeywords")) + ((cities)?"@"+cities.split(",").join("_") :((searchRegion&&searchRegion!="")?("@"+searchRegion.replace(/\ /gi,"_")):"@AllCities")) + ((bbox)?("["+bbox.map(function(v){return v.toFixed(1)}).join("_")+"]") :"") + ((startDate)?("("+startDate.replace(/\-/gi,"")+"-"+((endDate)?endDate.replace(/\-/gi,""):"")+")"):"") + ((removeRT>0&&removeRT!='false')?"_removeRT#"+removeRT:"") + ((removeURL>0&&removeURL!='false')?"_removeURL#"+removeURL:"") +((machineLearning)?"_machineLearning#True":"");


			//canvas obj
			if(canvasType){
				canvasType=canvasType.toUpperCase();
				if(canvasType&&bbox&&bbox.length==4){
					canvasObj=new API.common.canvasImage({canvasWidth:canvasWidth, canvasHeight:canvasHeight, heatmapRadius: heatmapRadius, bbox:bbox, type:canvasType})
				}
			}

			options["onEachTweet"]=function(t, num){
				var output=t,
					isDuplicate=false;

				//this may make performance slow!!!!!!!!!!!!!!1111
				if(removeDuplicate&&removeDuplicate=='true'){
					//key=t.user.id+"--!@#$--"+t.text
					key=t.user.id+"::"+t.text.substring(0,20)+"@"+t.text.length
					if(!distinctCache.containsKey(key)){
						distinctCache.put(key, true)
					}else{
						isDuplicate=true;
					}
				}

				if((format=='excel' || excel=='true')&&!isDuplicate){
					formatTweetXLS(t, keywords || texts, cities, num); //output will be in xlsStream
					output=null;
				}

				//canvas
				if(!isDuplicate&&canvasObj){
					var coords=t.coordinates;
					if(t&&coords&&coords.coordinates){
						canvasObj.addLatLng(coords.coordinates[1], coords.coordinates[0])
						//output=null;
					}
				}

				return output
			}

			//overwirte options onEachTweet
			if(nodeOptions.forEach){
				options['onEachTweet']=nodeOptions.forEach
			}

			//check topic
			if(topic.indexOf("archive_")!=-1){
				source="twitterArchive"
			}

			//check source
			switch(source){
				case "search":
					source="twitterSearchDB"
				break;
				case "streaming":
					source="twitterStreamingDB"
					delete query["search_info.topics"]

					//if no searchArea
					if(!searchArea || searchArea==""){
						delete query["search_info.search_areas.name"]
					}

					//if search region == sandiego >> change to San Diego region
					if(searchRegion&&searchRegion.toLowerCase()=="sandiego"){
						query["search_region"]="San Diego region"
					}

				break;
				case "twitterArchive":
					source="twitterArchive"
				break;
				default:
					res.end(JSON.stringify({error:"source is neither 'search' nor 'streaming'."}))
					return;
				break;
			}

			//limit && batchSize
			if(limit&&limit>10000){
				options['batchSize']=limit
			}

			//sort options
			options["sort"]={"created_at_local":-1}


			//check token >> temporally not check
			if(nodeOptions.checkToken){
				token="375d9690af0163335865871a46118884";
				if(token&&token!=""){

					//check token
					API.mongodb.query(mongodb, "userProfile", {token: token}, null, function(err, users){
						if(err){logger.info(err); res.end(JSON.stringify({error:err})); return; }

						//if token is not match
						if(users.length==0){
							err="token is not match. Please check again or contact administrator."
							logger.info(err); res.end(JSON.stringify({error:err})); return;
						}

						//query
						runQuery();
					});
				}
			}else{
				runQuery();
			}


			//query
			function runQuery(){
				//enforce query by a specific index
				if(query["search_info.topics"]&&source=='twitterSearchDB'&&cities!='none'){
					options.hint={"search_info.topics":1, "created_at_local":-1}

					if(query["text"]&&query["text"]["$all"]){
						options.hint={"search_info.topics":1, "text":1}
					}
				}

				//if format=html/map, just do query with limit=1 to pass the results to template map html.
				//it is because it will be trigger in the client side to get map width and height
				if(format=="html/map"){options.limit=1}

				//query mongodb
				API.mongodb.query(mongodb, source, query, options, function(err, results){
					if(err){logger.info(err); res.end(JSON.stringify({error:err})); return; }

					//clear distinctCache
					distinctCache=new HASHTABLE();

					//parse results
					if((excel=='true' || format=='excel')&&xlsStream!=""){
						//res
						//res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
						res.setHeader("Content-Type", "application/vnd.ms-excel;charset=utf-8,");
						//res.setHeader('Content-Type',"text/csv;charset=utf-8,%EF%BB%BF")
						res.setHeader("Content-Disposition", "attachment; filename="+filename+".xls");
						//the xlsStream has been pushed in options.onEachTweet
						res.end(xlsStream);
						return;
					}

					//heatmap or point canvas
					if(canvasObj){
						//draw result
						canvasObj.draw();

						//if format==image/png, directly output image
						if(format=='image/png'){
							res.type("png");
							res.end(canvasObj.canvas.toBuffer());
							return;
						}


						//if format=html/map, output image as file
						/**
						if(format=='html/map'){
							fs.writeFileSync("cache/canvas/"+filename+".png", canvasObj.canvas.toBuffer())
						}
						*/
					}



					var output=null
					if(results){
							output=results;

							if(format=='geojson'){
								output={
									type:"FeatureCollection",
									features:[]
								};
								var feature;

								results.forEach(function(result, i){
									feature={
										type:"Feature",
										properties:result,
										geometry:{
											type:"Point",
											coordinates:[]
										}
									}

									if(result.coordinates&&result.coordinates.coordinates&&result.coordinates.coordinates.length==2){
										feature.geometry=result.coordinates;
										output.features.push(feature)
									}
								});
							}
					}

					//output
					if(output){
						if(nodeOptions.callback){
							nodeOptions.callback(output, req.query)
						}else{
							if(jscallback){
								res.end(jscallback+"("+JSON.stringify(output)+")")
							}else{
								res.end(JSON.stringify(output))
							}
						}
					}




				});

			}//end query



			//formatTweetstoXLS
			function formatTweetXLS(t, keyword, city, num){
				var objs=[],
					obj_template={
						geocode_type:"NULL",
						"is_valid_only_for_Flu":"False",
						language:"NULL",
						source:"NULL",
						in_reply_to_status_id:"NULL",
						to_user_name:"NULL",
						geo:"NULL",
						time_zone:"NULL",
						statuses_count:0,
						friends_count:0,
						followers_count:0,
						retweet_count:0,
						is_retweet:false,
						//mentions:"NULL",
						hashtags:"NULL",
						urls:"NULL",
						location:"NULL",
						from_user_name:"NULL",
						from_user:"NULL",
						text:"NULL",
						created_at_local:"NULL",
						created_at:"NULL",
						city:city || ((t.search_info.search_areas[0])?t.search_info.search_areas[0].name:null),
						keyword:keyword || "NULL",
						tweet_id:"NULL"
					};

				//tweets.forEach(function(t,i){
					var obj=EXTEND({}, obj_template);

					//tweet id
					obj["tweet_id"]=String(t.id)

					//text
					if(t.text){obj["text"]=t.text}

					//created_at
					if(t.created_at){obj["created_at"]=t.created_at.toISOString().split(".")[0].replace("T"," ")}

					//create at local
					if(t.created_at_local){obj["created_at_local"]=t.created_at_local.toISOString().split(".")[0].replace("T"," ")}

					//urls
					if(t.entities&&t.entities.urls&&t.entities.urls.length>0){if(typeof(t.entities.urls[0])==='object'){var urls=[]; t.entities.urls.forEach(function(u){urls.push(u.url)}); obj["urls"]=urls.join(", ");}else{obj["urls"]=t.entities.urls.join(", ")}}

					//mentions
					//if(t.entities&&t.entities.user_mentions&&t.entities.user_mentions.length>0){obj["mentions"]=t.entities.user_mentions.join(", ")}

					//hashtags
					if(t.entities&&t.entities.hashtags&&t.entities.hashtags.length>0){if(typeof(t.entities.hashtags[0])==='object'){var hashtags=[]; t.entities.hashtags.forEach(function(u){hashtags.push(u.text)}); obj["hashtags"]=hashtags.join(", ");}else{obj["hashtags"]=t.entities.hashtags.join(", ")}}

					//search_ares
					//if(t.search_info&&t.search_info.search_areas&&t.search_info.search_areas.length>0){obj['search_areas']=t.search_info.search_areas.map(function(v){return v.name}).join(", ")}

					//time zone
					if(t.user&&t.user.time_zone){obj['time_zone']=t.user.time_zone}

					//is_retweet
					if(t.retweeted_id){obj['is_retweet']=true}

					//retweet count
					if(t.retweet_count>0){obj["retweet_count"]=t.retweet_count}

					//retweeted id
					//if(t.retweeted_id&&t.retweeted_id!=''){obj["retweeted_id"]=t.retweeted_id}

					//followers_count
					if(t.user&&t.user.followers_count){obj['followers_count']=t.user.followers_count}

					//firends count
					if(t.user&&t.user.friends_count){obj["friends_count"]=t.user.friends_count}

					//status count
					if(t.user&&t.user.statuses_count>=0){obj["statuses_count"]=t.user.statuses_count}

					//location
					if(t.user&&t.user.location){obj["location"]=t.user.location}

					//language
					if(t.lang){obj["language"]=t.lang}

					//from user
					if(t.user&&t.user.screen_name){obj["from_user"]=t.user.screen_name}

					//from user name
					if(t.user&&t.user.name){obj["from_user_name"]=t.user.name}

					//geo
					if(t.coordinates&&t.coordinates.coordinates){obj["geo"]=t.coordinates.coordinates.join(", ")}

					//source
					if(t.source){obj["source"]=$(t.source).text()}

					//chris adding this...hopefully it doesnt break the code
					if(t.is_valid) {
						obj['is_valid_only_for_Flu'] = t.is_valid;
					}

					//geocode type
					if(t.geocoded&&t.geocoded.status){
						var st=t.geocoded.status;
						if(st=='GPS tweet'){obj['geocode_type']='GPS'}
						if(st=='success'){obj['geocode_type']='userProfile'}
					}

					//objs.push(obj)

					//push data to excelData
					var keys=Object.keys(obj);
					if(num==0){
						//header
						keys.forEach(function(k,i){xlsStream+=k.toUpperCase()+((i==keys.length-1)?"":"\t")})
						xlsStream+='\n';
					}
					keys.forEach(function(k,i){xlsStream+=String(obj[k]).trim().replace(/(?:\r\n|\r|\n|\t)/g, " ")+((i==keys.length-1)?"":"\t")})
					xlsStream+="\n";

				//});

				//return objs
				return obj
			}
		},


		//get streaming keywords
		getKeyword: function(req, res, mongodb){
			var params={},
				type=req.params.type || "all";

			switch (type){
				case "streaming":
					//if request keyword
					if(req.query.keyword&&req.query.keyword!=""){
						params["keyword"]=req.query.keyword;
					}

					//limit to filterparameter=track
					params["filterParameter"]="track"

					if(mongodb){
						//query  mongodb
						API.mongodb.query(mongodb, "streamingTopics", params, {}, function(err, results){
							if(err){logger.error("[ERROR] hdma.data.getStreamingKeyword: "+ err); res.end(json.stringify(err)); return;}

							if(results&&results.length>0){
								var output=[];
								results.forEach(function(obj, i){
									output.push({
										keyword:obj.keyword,
										startDate:(obj.startDate)?obj.startDate.toISOString():null,
										endDate:(obj.endDate)?obj.endDate.toISOString():null,
										bbox:(obj.bbox)?obj.bbox:null,
										host:(obj.host)?obj.host:null
									})
								})

								res.end(JSON.stringify(output));
							}
						});
					}else{
						res.end("[ERROR] hdma.data.getStreamingKeyword: no mongodb");
					}
				break;

				case "all":
					if(mongodb){
						//get searchAPI db first
						API.mongodb.query(mongodb, "topics", {}, {}, function(err, results){
							if(err){logger.error("[ERROR] hdma.data.getKeyword in DB[twitterSearchDB]: "+ err); res.end(json.stringify(err)); return;}

							if(results&&results.length>0){
								var output={"searchAPI": [], "streamingAPI": []};

								results.forEach(function(obj, i){
									output.searchAPI.push({
										topic:obj.name,
										keyword:obj.keywords.map(function(o){return o.name}),
										startDate:(obj.startDate)?obj.startDate.toISOString():null,
										endDate:(obj.endDate)?obj.endDate.toISOString():null,
										searchAreas:(obj.searchAreas&&obj.searchAreas.length>0)?obj.searchAreas.length:false,
										hasTwitterSearchBoundary:obj.hasTwitterSearchBoundary
									})
								})

								//get streaming keywords
								API.mongodb.query(mongodb, "streamingTopics", {}, {}, function(err, data){
									if(err){logger.error("[ERROR] hdma.data.getKeyword in DB[streamingKeywords]: "+ err); res.end(json.stringify(err)); return;}

									if(data&&data.length>0){
										data.forEach(function(obj, i){
											output.streamingAPI.push({
												topic:obj.filterParameter,
												keyword:(obj.filterParameter=="track")?obj.keyword:obj.area,
												startDate:(obj.startDate)?obj.startDate.toISOString():null,
												endDate:(obj.endDate)?obj.endDate.toISOString():null,
												bbox:(obj.bbox)?obj.bbox:null,
												host:(obj.host)?obj.host:null
											})
										})

										res.end(JSON.stringify(output));
									}

								});
							}

						});

					}

				break;

			}


		},


		//get topic
		getTopic: function(req, res, mongodb){
			if(mongodb){
				var topicName=req.params.topic || null;

				if(topicName&&topicName!=""){
					//params
					var params={"name": topicName.toLowerCase()};

					if(topicName=='all'){
						params={}
					}

					//query topic in the mongodb
					API.mongodb.query(mongodb, "topics", params, null, function(err, results){
						if(err){logger.error("[ERROR] getTopic: "+ err); res.end(json.stringify(err)); return;}

						if(results&&results.length>0){
							var output=[];
							results.forEach(function(topic, i){
								output.push({
									name:topic.name,
									keywords:topic.keywords,
									startDate:(topic.startDate)?topic.startDate.toISOString():null,
									endDate:(topic.endDate)?topic.endDate.toISOString():null,
									cities:(topic.searchAreas)?topic.searchAreas:null
								})
							})

							res.end(JSON.stringify(output));
						}
					});
				}
			}else{
				res.end('[ERROR]: hdma.data.getTopic: no mongodb')
			}

		},


		//get layers
		getLayer: function(req, res, mongodb){
			var topic=req.params.topic;

			if(topic&&topic!=""){
				topic=topic.replace("--","+")

				if(topic=='sandiego'){topic='sanDiego'}

				//query topic in the mongodb
				API.mongodb.query(mongodb, "layers", {topics:topic}, null, function(err, results){
					if(!err){
						res.end(JSON.stringify(results))
					}
				});
			}
		}



	}, // end hdma.data



	//layer
	layer: function(req, res){
		var type=req.params.type || null,
			name=req.params.name || null,
			output={status:"ERROR", msg:"There is no type or name to request a layer. Please check again", value:null};

		if(type&&name){
			switch(type){
				case "nws":
					switch(name){
						case "cap":
							var url="",
								url_us="http://alerts.weather.gov/cap/us.php",
								url_area="http://alerts.weather.gov/cap/wwaatmget.php", //?x=CAC073&y=0
								parser=require('xml2json'),
								request=require('request'),
								x=req.query.x || "0",
								y=req.query.y || "0",
								f=req.query.f || "json"

							url=url_area;
							if(x=="0"&&y=="0"){url=url_us}

							//params
							url=url+"?x="+x+"&y="+y;

							//request
							request(url, function (error, response, body) {
							  if (!error && response.statusCode == 200) {
								var json=parser.toJson(body);

								switch(f){
									case "json":
										res.end(json)
									break;
									case "geojson":
									case "shp":
									case "kml":
										json=JSON.parse(json)
										var entry=json.feed.entry,
											geojson={
												type:"FeatureCollection",
												features:[]
											};


										if(entry instanceof Object && !entry.length){
											var out=parseJson(entry)
											if(out){geojson.features.push(out)}
										}else{
											if(entry instanceof Array){
												entry.forEach(function(item, i){
													var out=parseJson(item);
													if(out){geojson.features.push(out)}
												})
											}
										}


										//output
										switch(f){
											case "geojson":
												res.end(JSON.stringify(geojson)); return;
											break;
											case "shp":
												//convert geojson to shp
												var fileName=type+"-"+name+"_"+x+"_"+y;
												API.format.geojsonToShp(geojson, "public/temp/"+fileName+".zip", function(){
													res.redirect(API.common.getHostPath(req)+"/temp/"+fileName+".zip");
												})
											break;
											case "kml":
												//convert geojson to shp
												var fileName=type+"-"+name+"_"+x+"_"+y;
												API.format.geojsonToKml(geojson, "public/temp/"+fileName+".kml", function(e, data){
													if(e){res.end(JSON.stringify(e)); return}

													res.redirect(API.common.getHostPath(req)+"/temp/"+fileName+".kml");
												})
											break;
										}


										//parse each entry to convert to feature
										function parseJson(entry){
											var polygon=entry["cap:polygon"],
												feature=null;

											//polygon exists
											if(polygon&&polygon!=""&&!(polygon instanceof Object)){
												polygon=polygon.split(" ");
												var coordinates=[polygon.map(function(coords){coords=coords.split(","); return [parseFloat(coords[1]), parseFloat(coords[0])]})];

												feature={
													type:"Feature",
													geometry:{
														type:"Polygon",
														coordinates: coordinates
													},
													properties:(function(){
														var out={}, feed=json.feed;
														for(var k in feed){
															if(k!='entry'){out[k]=feed[k]}
														}
														for(var k in entry){
															out['entry-'+k]=entry[k]
														}
														return out
													})()
												};
											}
											return feature
										}
									break;
								}

							  }
							})
						break;
					}
				break;
			}





		}



	},


	//hdma.format
	format: {
		//geojson to shp
		geojsonToShp: function(geojson, outputPath, callback){
			var shp=OGR2OGR(geojson).format('ESRI Shapefile').skipfailures().stream()

			var r=shp.pipe(fs.createWriteStream(outputPath))

			//callback
			r.on("finish", function(){
				if(callback){
					callback();
				}
			})

			/**
			shp.exec(function(err, data){

			})
			*/
		},


		//geojsonToKml
		geojsonToKml: function(geojson, outputPath, callback){
			var	kml=OGR2OGR(geojson).format('KML').destination(outputPath).skipfailures(); //need to giv the desitination path, otherwise it will marke errors
			kml.exec(function(e,data){
				if(callback){
					callback(e,data)
				}
			})
		}


	}





	//test only
	/**
	test:{
		//heatmap
		getHeatmap: function(req, res){
			var heat = HEATMAP(500, 500, { radius : 30 });
			for (var i = 0; i < 5000; i++) {
				var rho = Math.random() * 2 * Math.PI;
				var z = Math.pow(Math.random(), 2) * 200;

				var x = 250 + Math.cos(rho) * z;
				var y = 250 + Math.sin(rho) * z;

				heat.addPoint(x, y);
			}
			heat.draw();

			//response
			res.writeHeader(200, {"Content-Type":"image/png"})
			res.end(heat.canvas.toBuffer(), "binary")



		}


	}
	*/

}//end API




//export api
module.exports=API;



//canvasImage
var canvasImage=API.common.canvasImage=function(options){
		options=options || {}
		this.type=options.type=options.type || "HEATMAP";
		this.canvasWidth=options.canvasWidth=options.canvasWidth || 0;
		this.canvasHeight=options.canvasHeight=options.canvasHeight || 0;
		this.heatmapRadius=options.heatmapRadius=options.heatmapRadius || 10;
		this.bbox=options.bbox=options.bbox || null;
		this.rgba=options.rgba=options.rgba || [255,0,0,255];

		//recalculate width and height by bbox
		if(this.canvasWidth==0 || this.canvasHeight==0){
			var bbox=this.bbox,
					ratio=Math.abs(bbox[2]-bbox[0]) / Math.abs(bbox[3]-bbox[1]);   //width / height
			this.canvasHeight=256;
			this.canvasWidth=Math.round(this.canvasHeight * ratio);
		}

		//heat obj
		this.canvas=new CANVAS(this.canvasWidth, this.canvasHeight);
		this.heat=new HEATMAP(this.canvas,{radius:this.heatmapRadius});
		//this.heat=new HEATMAP(this.canvasWidth, this.canvasHeight,{radius:this.heatmapRadius});
		//this.canvas=this.heat.canvas;
		this.ctx=this.canvas.getContext("2d");
		this.canvasData=this.ctx.getImageData(0,0,this.canvasWidth, this.canvasHeight);

		//add image
		this.markerIcon=null;
		if(this.type.toUpperCase()=='MARKER'){
			//here we need to use the same canvas from Heatmap. we cannot create it from CANVAS (var img=new CANVAS.Image)
			//otherwise, there is an error showing that "canvas or image is expected"
			//thus,
			// 1)we need to customize the index.js in the heatmap folder in the node_module to export Image class
			// OR 2) just rename or delete canvas folder in the heatmap node_module to make sure it read the canvas in the global.
			var img=new CANVAS.Image;
			//var img=new HEATMAP.Image;
			img.src=fs.readFileSync("./public/common/js/leaflet/images/marker-icon.png");
			/**
			fs.readFile("public/common/js/leaflet/images/marker-icon.png", function(e, data){
				console.log(e)
				console.log(data)
			})
			*/
			this.markerIcon=img;
		}

		//data
		this.latlngs=[];
}

//prototypes
canvasImage.prototype.lnglatToPixel= function(lng, lat){
			var bbox=this.bbox,
					width=this.canvasWidth,
					height=this.canvasHeight;


			if(bbox&&bbox instanceof Array&&bbox.length==4){
				var original_lng=bbox[0],
						original_lat=bbox[3],
						lngSpan=Math.abs(bbox[2] - bbox[0]),
						latSpan=Math.abs(bbox[3] - bbox[1]);

				//return [(Math.abs(lng - original_lng) / lngSpan) * width, (Math.abs(original_lat - lat) / latSpan) * height]

				var x = (lng - original_lng) * (width / lngSpan);
				lat = lat * Math.PI / 180;
				var worldMapWidth = ((width / lngSpan) * 360) / (2 * Math.PI);
				var latBottomDegree= bbox[1] *Math.PI/180;
				var mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(latBottomDegree)) / (1 - Math.sin(latBottomDegree))));
				var y = height - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);

				return [Math.round(x), Math.round(y)]
			}
}
canvasImage.prototype.addLatLng= function(lat, lng){
			var latlngs=this.latlngs,
					type=this.type,
					xy=this.lnglatToPixel(lng, lat),
					index=0,
					rgba=this.rgba,
					width=this.canvasWidth,
					ctx=this.ctx,
					markerIcon=this.markerIcon,
					canvasData=this.canvasData;


			if(xy&&xy.length==2){
				//HEATMAP
				if(type=='HEATMAP'){
					this.heat.addPoint(xy[0], xy[1])
				}

				//point
				if(type=='POINT'){
					index=(xy[0] + xy[1]*width)*4;
					rgba.forEach(function(c,j){
						canvasData.data[index+j]=c;
					})
				}

				//MARKER //not finished!
				if(type=='MARKER'){
					//ctx.font="40px FontAwesome";
					//ctx.fillText("\uf000", xy[0], xy[1]);
					//console.log(markerIcon, markerIcon.width)
					ctx.drawImage(markerIcon, xy[0], xy[1], markerIcon.width/2, markerIcon.height/2)

				}

				latlngs.push([lat,lng])
			}
}
canvasImage.prototype.draw=function(){
	var type=this.type;

	switch(type){
		case "HEATMAP":
			this.heat.draw()
		break;
		case "POINT":
			this.ctx.putImageData(this.canvasData, 0, 0 )
		break;
		case "MARKER":

		break;
	}
}








//overwrite MetaInspector
if(MetaInspector){
	MetaInspector.prototype.fetch = function(){
		var _this = this;
		var totalChunks = 0;

		var r = REQUEST({uri : this.url, followAllRedirects: true, followRedirect:true, method: "HEAD" }, function(error, response, body){
			if(response){
				//only focus on html/text. Otherwise, it will make "max-stack size exceeded" error!!!!!
				var contentType=response.headers["content-type"];

				if(!error && response.statusCode === 200 && contentType && (contentType.indexOf("text/html")!=-1)){
					_this.document = body;
					_this.parsedDocument = $.load(body);
					_this.response = response;

					_this.initAllProperties();

					_this.emit("fetch");
				}
				else{
					_this.emit("error", error, contentType);
				}
			}
		});

		if(_this.options.limit){
			r.on('data', function(chunk){
				totalChunks += chunk.length;
				if(totalChunks > _this.options.limit){
					_this.emit("limit");
					r.abort();
				}
			});
		}
	};

}
