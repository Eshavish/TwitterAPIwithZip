var MONGOCLIENT=require("mongodb").MongoClient,
		Q=require("q"),
	  LOGGER=require("../../config/logger.js");

//FACTORY
module.exports=function(){
  return new Mongodb();
}


//CLASS
var Mongodb=function(){
  //properties
  //cached database connection to increase the performance
  this.cacheDB={};
}



/**
 * Connect Mongo
 * @param {String} url
 * @param {Number} port
 * @param {String} dbname
 * @param {callback} callback function. return db object
 */
Mongodb.prototype.connect=function(url, dbname, callback){
			url=url || "";
			dbname=dbname || "";

			//defer
			var $q=Q.defer(),
					mongodb=this.cacheDB;

			if(url!='' && dbname!=""){
				var path="mongodb://"+url+"/"+dbname;

				if(mongodb[url] && mongodb[url][dbname]){
					$q.resolve(mongodb[url][dbname])

					LOGGER.info('*************************************************************************')
					LOGGER.info("mongodb connected (existed): "+ path)

					/**
					if(callback){
						callback(mongodb[url][dbname]);

						LOGGER.info('*************************************************************************')
						LOGGER.info("mongodb connected (existed): "+ path)
					}
					*/

				}else{
					MONGOCLIENT.connect(path, function(error, db){
						if(error) {
							$q.reject(err)
						}else{
							if(!mongodb[url]){mongodb[url]={}}

							if(!mongodb[url][dbname]){mongodb[url][dbname]=db}

							$q.resolve(mongodb[url][dbname])
							/**
							if(callback){
								callback(mongodb[url][dbname])
							}
							*/

							LOGGER.info('*************************************************************************')
							LOGGER.info("mongodb connected (new): "+ path)
						}


					})
				}
			}else{
				$q.reject("[ERROR] hdma.utilities.connectMongo: no URL, PORT, and DBNAME")
				LOGGER.error("[ERROR] hdma.utilities.connectMongo: no URL, PORT, and DBNAME");
			}

			//return promise
			return $q.promise.nodeify(callback)
}



/**
 * query collection in a mongodb
 * @param (mongodb) mongodb object
 * @param {String} collectionName: collection name
 * @param {Object} query
 * @param {Object} options
 * @param {callback} callback function. return error and results array
 */
Mongodb.prototype.query=function(db, collectionName, query, options, callback){
			LOGGER.info('*************************************************************************')
			LOGGER.info('querying MongoDb. collection=' + collectionName)
			var startQuery=new Date();
			LOGGER.info('query at= '+startQuery)
			LOGGER.info('query params=')
            //CHRIS: I changed this to only print out the first 100 characters of the query
            //because I am doing some queries with a list of many IDs, which take a while
            //to print to the command line...
			//Calvin: extend to 500 characters..need to see some parameters
			LOGGER.info(JSON.stringify(query).substring(0, 500));
			LOGGER.info('query options=')
			LOGGER.info(options)

			var err={
				"a":"[ERROR] hdma.mongodb.query: no db, collection,or query object.",
				"b":"[ERROR] hdma.mongodb.query: no collection in db."
			}, defer=Q.defer();

			if(!options){options={}}
			options.fields=options.fields || null;
			options.sort=options.sort || null;
			options.limit=options.limit || 1000;
			options.batchSize=parseInt(options.batchSize) || null;
			options.onEachTweet=options.onEachTweet || null

			if(db && collectionName && collectionName!='' && query){
				var col=db.collection(collectionName)

				if(col){
					var cursor=col.find(query, options);

					//explain cursor
					cursor.explain(function(err, result){
						LOGGER.info('*************************************************************************')
						LOGGER.info('Index:')
						if(result){
							var out={};
							["cursor","isMultiKey","n","nscannedObjects","nscanned","nscannedObjectsAllPlans","nscannedAllPlans", "scanAndOrder","indexOnly","nYields", "nChunkSkips", "millis"].forEach(function(k){
								if(result[k]){out[k]=result[k]}
							})
							LOGGER.info(out)
						}
					})


					if(options.limit<=10000){
						/** directly convert to Array, but not good for large datasets
						col.find(query, options).toArray(function(error, results){
							if(error){
								LOGGER.error("[ERROR] hdma.mongodb.query:" + error);
								if(callback){callback(error, null)}
								return;
							}else{
								LOGGER.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s")
								if(callback){callback(null, results)}
							}
						});
						*/

						//on each
						var results=[], num=0;
						cursor.each(function(err, doc){
							if(err){
								LOGGER.error("[ERROR] hdma.mongodb.query:" + err);
								defer.reject(err);

								//if(callback){callback(err, null)}
								return;
							}

							process.nextTick(function(){
								if(doc){
										if(options.onEachTweet){
											var obj=options.onEachTweet(doc, num);
											if(obj&&obj!=null){
												results.push(obj)
											}
										}else{
											results.push(doc)
										}
										num++;


								}else{
									LOGGER.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s")
									LOGGER.info('result.length='+results.length)

									defer.resolve(results);
									//if(callback){callback(null, results)}
								}
							})
						})


					}else{
						LOGGER.info("use Streaming to retrieve mongo data");
						var results=[],num=0;
						//options.explain=true;

						//if options.sort exists, it will decrease performance especially when query lots of datasets (more than 20000)
						//need to set options.sort=null
						//however, it can be improved by setting compound index (set index on two more field at the same time. such as keywords+created_at_local)

						/** streaming */
						var stream=cursor.stream();
						stream.on("error", function(err){LOGGER.error("[ERROR] hdma.mongodb.query:" + err); if(callback){callback(err,null)}})
						stream.on("data", function(doc){
							process.nextTick(function(){
								if(options.onEachTweet){
									var obj=options.onEachTweet(doc, num);
									if(obj&&obj!=null){
										results.push(obj)
									}
								}else{
									results.push(doc)
								}
								num++;

								if(num%10000==0){
									console.log(num)
								}
							});

						})
						stream.on("close", function(){
							LOGGER.info("QueryTime= "+ (new Date()-startQuery)/1000+ "s");
							startQuery=new Date();

							defer.resolve(results);
							//if(callback){callback(null, results)}
							LOGGER.info("ProcessTime= "+ (new Date()-startQuery)/1000+ "s");
						});

					}

				}else{
					LOGGER.error(err["b"])
					defer.reject(err["b"]);
					//if(callback){callback(err["b"], null)}
					return;
				}
			}else{
				LOGGER.error(err["a"]);
				defer.reject(err["a"]);
				//if(callback){
					//callback(err["a"], null)
				//}
			}


		return defer.promise.nodeify(callback)
}


/**
 * update collection
 * @param (mongodb) mongodb object
 * @param {String} collectionName: collection name
 * @param {Object} selector
 * @param {Object} params
 * @param {Object} options
 * @param {callback} callback function. return error and result
 */
Mongodb.prototype.update=function(db, collectionName, selector, params, options, callback){
			LOGGER.info('*************************************************************************')
			LOGGER.info('updating MongoDb. collection=' + collectionName)
			LOGGER.info('update on= ')
			LOGGER.info(selector)
			//LOGGER.info('where params=')
			//LOGGER.info(JSON.stringify(params));
			LOGGER.info('query options=')
			LOGGER.info(options)

			var collection=db.collection(collectionName, function(err, col){
				col.update(selector, params, options, function(e, result, status){
					if(callback){
						callback(e, result, status)
					}
				})
			});

}



/**
 * insert collection
 * @param (mongodb) mongodb object
 * @param {String} collectionName: collection name
 * @param {Object or array}
 * @param {Object} options
 * @param {callback} callback function. return error and result
 */
Mongodb.prototype.insert=function(db, collectionName, docs, options, callback){
			LOGGER.info('*************************************************************************')
			LOGGER.info('inserting MongoDb. collection=' + collectionName)
			LOGGER.info('insert options=')
			LOGGER.info(options)

			var collection=db.collection(collectionName, function(err, col){
				col.insert(docs, options, function(e, result){
					if(callback){
						callback(e, result)
					}
				})
			});
}


/**
 * save collection
 * @param (mongodb) mongodb object
 * @param {String} collectionName: collection name
 * @param {Object}
 * @param {Object} options
 * @param {callback} callback function. return error and result
 */
Mongodb.prototype.save=function(db, collectionName, doc, options, callback){
			LOGGER.info('*************************************************************************')
			LOGGER.info('saving MongoDb. collection=' + collectionName)
			LOGGER.info('save options=')
			LOGGER.info(options)

			var collection=db.collection(collectionName, function(err, col){

				//return;
				col.save(doc, options, function(e, result){
					if(callback){
						callback(e, result)
					}
				})
			});
}



/**
 * count collection in a mongodb
 * @param (mongodb) mongodb object
 * @param {String} collectionName: collection name
 * @param {Object} query
 * @param {Object} options
 * @param {callback} callback function. return error and count
 */
Mongodb.prototype.count=function(db, collectionName, query, options, callback){
			LOGGER.info('*************************************************************************')
			LOGGER.info('count MongoDb. collection=' + collectionName)
			var startQuery=new Date();
			LOGGER.info('count at= '+startQuery)
			LOGGER.info('count params=')
			LOGGER.info(query)


			if(!options){options={}}
			//options.fields=options.fields || null;
			//options.sort=options.sort || null;
			//options.limit=options.limit || 1000;
			//options.batchSize=parseInt(options.batchSize) || null;

			if(db && collectionName && collectionName!='' && query){
				var col=db.collection(collectionName);

				col.find(query).count(callback)
			}
}
