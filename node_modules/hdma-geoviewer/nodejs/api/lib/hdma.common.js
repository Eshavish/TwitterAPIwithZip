var FS=require("fs"),
		NODEXLS=require("excel-export"),
		METAINSPECTOR=require("node-metainspector"),
		$=require("cheerio"),
		MOMENT=require("moment"),
		NODEMAILER=require("nodemailer"),
		//HEATMAP=require("heatmap"),
		CLIENT=null,
		OG=require("open-graph"),
		LOGGER=require("../../config/LOGGER.js"),
		HASHTABLE=require('jshashtable'),
		MERCATOR=require("sphericalmercator"),
		MERC=new MERCATOR({size:256}),
		CANVAS=null,
		HEATMAP=null,
		CACHEDOPENGRAPH=new HASHTABLE(),
		REQUEST=require("request"),
		CRAWLER=require("crawler"),
		crawlerEngine=new CRAWLER({
			maxConnection:10,
			callback: function(err, result, $){

			}
		}),
		HDMA_MONGODB=require("./hdma.mongodb")();



//FACTORY
module.exports=function(){
	var output=new Common();

	//load canvas and heatmap. If you havenot install canvas and heatmap, it will return null
	CANVAS=output.require("canvas");
	HEATMAP=output.require("heatmap");

  return output;
}



//CLASS
var Common=function(){


}


//check require is exists or not. If not existed, return NULL
Common.prototype.require=function(lib_string){
		var output=null;
		try{
			output=require(lib_string)
		}
		catch(e){
			//if there is any error while requiring LIB, return null
			output=null
		}
		finally{
			return output;
		}
}


//init GMailing system
Common.prototype.gmailTransporter=function(options){
	options=options || {}
	options.email=options.email || null;
	options.clientID=options.clientID || null;
	options.clientSecret=options.clientSecret || null;
	options.refreshToken=options.refreshToken || null;
	options.accessToken=options.accessToken || null;

	var xoauth2_gmail=null;
	if(options.email && options.clientID && options.clientSecret && options.refreshToken && options.accessToken){
		var xoauth2_gmail=require("xoauth2").createXOAuth2Generator({
			user:options.email,
			clientID:options.clientID,
			clientSecret:options.clientSecret,
			refreshToken:options.refreshToken,
			accessToken:options.accessToken
		});
		
		//xoauth2 and nodemailer
		xoauth2_gmail.on('token', function(token){
			console.log("*****************************************************")
			console.log('New token for %s: %s', token.user, token.accessToken);
			console.log("*****************************************************")
		})

		//properties
		this._transporter=NODEMAILER.createTransport({
			service:"gmail",
			auth:{
				xoauth2:xoauth2_gmail
			}
		});

		return this._transporter;
	}else{
		return null
	}


}




//get server name
Common.prototype.getServerName=function(){
	var ipAddress=(function(){
		var ip=null
		require("os").networkInterfaces()["Local Area Connection"].forEach(function(obj,i){
			if(obj.family=='IPv4'&&obj.address.split(".").length==4){
				ip=obj.address
			}
		})
		return ip
	})();

	return (ipAddress=='130.191.118.59')?"vision":"ec2";
}



/**
 *  check if user loggin by passport
 */
Common.prototype.ensureAuthenticated=function(options){
		var that=this;

		options=options || {};
		options.type=options.type || "twitter";
		options.failureCallback=options.failureCallback || function(req, res){
			//res.redirect("/"+that.getHostPath(req)+"/auth/"+options.type+"/failure");
			//go to authorty page again
			//res.redirect("/"+that.getHostPath(req)+"/auth/"+options.type+((options.returnTo)?("?returnTo="+options.returnTo):""));
			res.redirect("/"+that.getHostPath(req)+"/auth/"+options.type+"?returnTo="+req.path);
		}

		return function(req, res, next){
			if(req.isAuthenticated()){
				next();
			}else{
				options.failureCallback(req, res)
			}
		}
}


/**
 *	parseFeatures
 *	@param (Array) results
 *	@param (String) geometryFieldName
 *	@param (Object) options{
 *		geomasking (Boolean): default is false
 *		geomaskingRadius (Number): unit is meter. default is 0
 *		hideProperties (Array): the properties would not like to show in the geojson
 *  }
 *  @return (Array) geojson feature array
*/
Common.prototype.parseFeatures=function(results, geometryFieldName, options){
		if(!results || !geometryFieldName || geometryFieldName==''){LOGGER.error("[ERROR] hdma.common.parseFeatures: no results, geometryFieldName."); return;}


		//options
		if(!options){options={}}
		options.geomasking=options.geomasking || false;
		options.geomaskingRadius=options.geomaskingRadius || 0;
		options.hideProperties=options.hideProperties || ["_id"]


		var features=[], feature, geo,
			radius=options.geomaskingRadius,
			hideProperties=options.hideProperties,
			that=this;

		//parse
		for(var i=0,length=results.length;i<length;i++){
			feature=results[i];
			geo=feature[geometryFieldName]

			feature={"type":"Feature","properties":feature, "geometry":{"type":"Point", "coordinates":[geo.coordinates[1], geo.coordinates[0]]}};

			//geomasking
			if(options.geomasking){
				feature["geomasked_geometry"]={"type":"Point", "coordinates":[that.geomasking(geo.coordinates[1],radius), that.geomasking(geo.coordinates[0],radius)]}
			}


			//delete properties
			for(var j=0,l=hideProperties.length;j<l;j++){
				delete feature.properties[hideProperties[j]]
			}


			features.push(feature);
		}

		return features
}


/**
 *	geomasking
 *	@param (Number) number
 *	@param (Number) radius. the unit is meter
 *  @return (Number) a random number within the radius
*/
Common.prototype.geomasking=function(num, radius){
		var randomNumber=Math.floor(Math.random()*(radius+1))-radius;
		return (num + ((randomNumber/111000))).toFixed(7);
}



//write a file
Common.prototype.writeFile=function(filePathAndName, data, callback){
		//check if exist
		FS.exists(filePathAndName, function(exists){
			if(exists){
				//delete file
				FS.unlink(filePathAndName, function(err){
					write()
				})
			}else{
				write()
			}
		});

		function write(){
			//FS.writeFile(filePathAndName, data, function(err){
			FS.appendFile(filePathAndName, JSON.stringify(data, null, 4), function(err){
				if(callback){
					callback(err)
				}
			})
		}
}



//read a file
Common.prototype.readFile=function(filePathAndName, callback){
		FS.readFile(filePathAndName, function(err, data){
			if(callback){
				callback(err, data)
			}
		})
}



//export to xls
Common.prototype.exportXLS=function(dataArray, options){
		if(!dataArray || dataArray.length==0){LOGGER.error("[ERROR] hdma.common.exportXLS: no dataArray"); return; }

		if(!options){options={}}
		options.stylesXmlFile='style/styles.xml'; //style file. we can design xls style first and make conf to read the style file.

		var conf={
			cols:[],
			rows:[],
			stylesXmlFile:options.stylesXmlFile
		};

		//read data
		var data;
		for(var i=0; i<dataArray.length; i++){
			data=dataArray[i];

			var rows=[]
			for (key in data){
				if(i==0){
					conf.cols.push({
						caption:key.toUpperCase(),
						type:typeof(data[key])
					});
				}

				rows.push(data[key]);
			}
			conf.rows.push(rows);
		}

		return NODEXLS.execute(conf);
}



//using node-metainspector to fetch webpage info
Common.prototype.fetch=function(req, res){
		var url=req.query.url || "",
			result={};

		if(url!=""){
			//if the url is not cache in the CACHEDOPENGRAPH, then fetch it
			if(!CACHEDOPENGRAPH.containsKey(url)){

				//process.nextTick(function(){
					CLIENT=new METAINSPECTOR(decodeURIComponent(url), {});

					CLIENT.on("fetch", function(){
						result={
							title: parse(CLIENT, "title"), //(CLIENT.title&&typeof(CLIENT.title)=='function')?CLIENT.title():CLIENT.title,
							url: parse(CLIENT, "url"), //(CLIENT.url)?CLIENT.url:null,
							scheme: parse(CLIENT, "scheme"), //(CLIENT.schema)?CLIENT.scheme:null,
							host: parse(CLIENT, "host"), //(CLIENT.host)?CLIENT.host:null,
							rootUrl: parse(CLIENT, "rootUrl"), //(CLIENT.rootUrl)?CLIENT.rootUrl:null,
							//links: parse(CLIENT, "links"), //(CLIENT.links&&CLIENT.links())?CLIENT.links():null,
							author: parse(CLIENT, "author"), //(CLIENT.author&&typeof(CLIENT.author)=='function')?CLIENT.author():null,
							keywords: parse(CLIENT, "keywords"), //(CLIENT.keywords&&typeof(CLIENT.keywords)=='function')?CLIENT.keywords():null,
							metaDescription: parse(CLIENT, "metaDescription"), //(CLIENT.metaDescription&&typeof(CLIENT.metaDescription)=='function')?CLIENT.metaDescription():null,
							description: parse(CLIENT, "description"), //(CLIENT.description&&typeof(CLIENT.description)=='function')?CLIENT.description():null,
							images: parse(CLIENT, "images"), //(CLIENT.images&&typeof(CLIENT.images)=='function')?CLIENT.images():null,
							image: parse(CLIENT, "image"), //(CLIENT.image&&typeof(CLIENT.image)=='function')?CLIENT.image():null,
							//feeds: parse(CLIENT, "feeds"), //(CLIENT.feeds&&typeof(CLIENT.feeds)=='function')?CLIENT.feeds():null,
							ogtitle: parse(CLIENT, "ogtitle") //(CLIENT.ogtitle&&typeof(CLIENT.ogtitle)=='function')?CLIENT.ogtitle():null
						};

						//if the result contains strange characters >> replace with url
						result["description"]=(result["description"]&&result["description"].indexOf("ï¿½")!=-1)?result["url"]:result["description"];

						CACHEDOPENGRAPH.put(CLIENT.url, result)

						//console.log(result)
						res.end(JSON.stringify(result));
					})

					CLIENT.on("error", function(err, response){
						res.end(JSON.stringify({error:err, response:response}))
					})

					CLIENT.fetch();


				//})

			}else{
				res.end(JSON.stringify(CACHEDOPENGRAPH.get(url)))
				LOGGER.info("********************************************************")
				LOGGER.info(url +" is existed in the CACHEDOPENGRAPH")
			}


		}else{
			res.end('NO URL!!');
		}


		//parse
		function parse(obj, elem){
			var output=null;

			if(obj&&obj[elem]){
				output=obj[elem];

				//cheerio object
				if(typeof(obj[elem])=='object'&&!(obj[elem] instanceof Array)){
					//use get() to get all elements and convert to array
					output=obj[elem].get()
				}

			}

			return output;
		}

}



//opengraph
Common.prototype.opengraph=function(req, res){
		var url=req.query.url || "";
		if(url!=""){
			OG(url, function(err, meta){
				if(err){res.send(JSON.stringify(err)); return;}

				res.send(JSON.stringify(meta))
			})



		}else{
			res.send("NO URL!!");
		}
}



//get body html from a webpage
Common.prototype.getHtml=function(host, path, options, callback){
		if(!options){options={}}

		options.username=options.username || "";
		options.password=options.password || "";
		options.replaces=options.replaces || []; //["getTopics.py", "getTweets.py", "loading_bar.gif"];
		options.replacePath=options.replacePath || "";

		var http=require('http'),
			params={
				host:host,
				path:path
			},
			body="";

		if(options.username&&options.username!=""&&options.password&&options.password!=""){
			params["auth"]=options.username+":"+options.password;
		}

		var request=http.request(params, function(result){
			//console.log('STATUS: ' + result.statusCode);
			//console.log('HEADERS: ' + JSON.stringify(result.headers));
			result.setEncoding('utf8');
			result.on('data', function (chunk) {
				body+=chunk
			});
			result.on('end', function(){
				//replace file path
				options.replaces.map(function(v,i){
					body=body.replace(v, options.replacePath+v);
				});

				if(callback)(
					callback(body)
				)
			});
		});

		request.on('error', function(e) {
			console.log('problem with request: ' + e.message);
		});

		request.end();
}



//use crawler lib to crawl web content
Common.prototype.crawler=function(req, res){
		var url=decodeURIComponent(req.query.url) || null;

		if(url){
			crawlerEngine.queue({
				uri: url,
				callback: function(err, result, $){
					/** don't have time to figure out
					console.log(err)
					if(err){res.end(JSON.stringify(err)); return; }

					var urls=""
					$('a').each(function(i,v){
						urls+=$(v).attr("href")
					})
					res.end($("title").html())
					*/
				}
			})
		}


}


//login
Common.prototype.login=function(username, password, mongodb, callback){
		var crypto=require('crypto'),
			md5=crypto.createHash('md5');

		if(username&&username!=""&&password&&password!=""){
			//connect to user profile collection in mongodb to verify the username
			HDMA_MONGODB.query(mongodb, "userProfile", {"username": username}, null, function(err, results){
				var output={status:"error", msg:"Username or password is not correct."};

				if(err){
					output.msg=err
				}else{
					if(results&&results.length>0){
						var hash,
							profile=results[0]; //should be only one result (username)

						//hash password
						hash=md5.update(profile.password).digest('hex');

						if(password==hash){
							output={status:"ok", username:username, html:{download:""}, token:profile.token, groups:profile.groups, topics:profile.topics, note_geoviewer:profile.note_geoviewer, bookmarks:profile.bookmarks}
						}else{
							//incorrect password
							output.msg="The password does not match. Please check and try again."
						}
					}else{
						//no username
						output.msg="The username, "+ username+", does not match. Please check and try again."
					}
				}

				//callback
				if(callback){callback(output)}
			})
		}

}


//parse URL params
Common.prototype.parseURL=function(req){
		var params={},
			obj={
				topic:req.params.topic || req.query.topic || "all",
				keywords:req.query.keywords || null,
				texts:req.query.texts || null,
				cities:req.query.cities || null,
				excel:req.query.excel || false,
				startDate:req.query.startDate || null,
				endDate:req.query.endDate || null,
				gps:req.query.gps || false,
				source:req.query.source || "search",
				limit:req.query.limit || 1000,
				sort:req.query.sort || null,
				loc:req.query.loc || null,
				radius:req.query.radius || null,
				format:req.query.format || "json",
				jscallback:req.query.jscallback || null,
				url:req.query.url || null,
				groupBy: req.query.groupBy || "search_info.search_areas.0.name",
				mentions:req.query.mentions || null,  //without @
				hashtags:req.query.hashtags || null,  //without #
				removeRT:req.query.removeRT || 0,
				removeURL:req.query.removeURL || 0,
				hasMedia:req.query.hasMedia || false,
				media:req.query.media || null,
				retweeted_id:req.query.retweeted_id || null,
				removeDuplicate:req.query.removeDuplicate || false,
				batchSize:req.query.batchSize || null,
				isFilter:req.query.isFilter || false,
				token:req.query.token || null,
				machineLearning: req.query.machineLearning || false,
				bbox:req.query.bbox || null,
				polygon:req.query.polygon || null,
				searchArea:req.query.searchArea || null,
				searchRegion:req.query.searchRegion || null,
				canvasType: req.query.canvasType || null,  //HEATMAP OR POINT
				canvasWidth: req.query.canvasWidth || null,
				canvasHeight: req.query.canvasHeight || null,
				heatmapRadius: req.query.heatmapRadius || null
			},
			fields={"lang":1, "search_info":1, "entities":1, "text":1, "created_at":1, "created_at_local":1, "source":1, "user":1, "id":1, "_id":0, "coordinates":1, "retweeted_id":1, "is_valid":1, "geocoded":1};


		//params
		if(obj.topic!="all"){
			params["search_info.topics"]=obj.topic;
			if(obj.topic.indexOf("archive_")!=-1){obj.source="twitterArchive";}
			if(obj.topic.indexOf("streaming")!=-1){obj.source="streaming";}
		}
		if(obj.keywords){params["search_info.keywords"]=(obj.keywords.split(",").length==1)?obj.keywords.split(",")[0]: {"$in": obj.keywords.split(",")}}//.map(function(k){return new RegExp(k, "i")})}}
		if(obj.cities || obj.searchArea){
			if(obj.cities&&obj.cities!='none'){
				params["search_info.search_areas.name"]=(obj.cities.split(",").length==1)?obj.cities.split(",")[0]: {"$in":obj.cities.split(",")}
			}

			//search area
			if(obj.searchArea&&obj.searchArea!=""){
				obj.searchArea=obj.searchArea.toLowerCase();
				params["search_info.search_areas.name"]=((obj.searchArea=="sandiego")?"San Diego region":obj.searchArea)
			}
		}
		if(obj.searchRegion){
			params["search_region"]=obj.searchRegion

			//delete search_info.search_areas.name
			delete params["search_info.search_areas.name"]
		}
		if(obj.startDate || obj.endDate){
			var dateParam={}
			if(obj.startDate){dateParam["$gte"]= new Date(MOMENT(obj.startDate).format("YYYY-MM-DDT00:00:00+00:00"))}
			if(obj.endDate){dateParam["$lt"]=new Date(MOMENT(obj.endDate).format("YYYY-MM-DDT00:00:00+00:00"))}
			params["created_at_local"]=dateParam;
		}
		if(obj.format=='geojson'){obj.gps=true;}
		if(obj.gps){params["geo"]={"$exists":true}}
		if(obj.loc){
			params["coordinates.coordinates"]={};
			params["coordinates.coordinates"]["$near"]=obj.loc.split(',').map(function(v){return parseFloat(v)})
			if(radius&&!isNaN(obj.radius)){params["coordinates.coordinates"]["$maxDistance"]=parseFloat(obj.radius)}
		}
		if(obj.texts){
			//params['text']["$all"]= obj.texts.split(',').map(function(k){return new RegExp("[#@ ^/]"+k+" ", "gi")})
			params["$text"]={"$search":obj.texts.split(",").map(function(k){return "\""+k+"\""}).join(" ")}

			if(obj.source=='search'){params['text']={"$all": obj.texts.split(',').map(function(k){return new RegExp("(^| |[#@ ^/])"+k+"(|\W| |$|.$)", "gi")})};  delete params["$text"]}
		}
		if((obj.removeRT!=0&&obj.removeRT!="false") || (obj.removeURL!="false"&&obj.removeURL!=0)){
			params["text"]={}

			if(obj.removeRT){
				switch(String(obj.removeRT)){
					case "1":
						//REMOVE ALL TWEET START WITH 'RT' >> keep personal comments
						params['text']['$nin']=[/^RT /];
					break;
					case "2":
						//REMOVE ALL TWEET START WITH 'RT' OR CONTAIN 'RT' >> remove rt and remove personal comments
						params['text']['$nin']=[/( |^)RT /];
						//if(params["$text"] && params["$text"]["$search"] && params["$text"]["$search"] !=""){
							//params["$text"]["$search"]+=" -RT";
						//}

					break;
				}
			}
			if(obj.removeURL){
				switch(String(obj.removeURL)){
					case "1":
						//REOMVE A TWEET WHICH ONLY CONTAINS ONE URL, NO OTHER COMMENTS
						params['text']['$in']=[/^(?!(http[^\s]*$))/]
					break;
					case "2":
						if(!params['text']['$all'] && !params['text']['$nin']){delete params['text']}
						//REMOVE A TWEET WHICH CONTAINS URL
						params["entities.urls.0"]={'$exists': false}
						params["entities.media.0"]={'$exists': false}
					break;
				}
			}

			//if(removeURL){
			//	params['text']['$nin']=(params['text']['$nin']&&params['text']['$nin'].length>0)?params['text']['$nin'].concat([/http/ig, /https/ig]):[/http/ig, /https/ig]
			//}
		}
		//if(removeURL){params["entities.urls.0"]={'$exists': false}}
		//if(removeRT){params["retweeted_id"]={'$exists': false}}
		if(obj.mentions){params['entities.user_mentions']=(obj.mentions.split(",").length==1)?obj.mentions.split(",")[0]: {"$all": obj.mentions.split(',').map(function(k){return new RegExp(k, "i")})}}
		if(obj.hashtags){params['entities.hashtags']=(obj.hashtags.split(",").length==1)?obj.hashtags.split(",")[0]: {"$all": obj.hashtags.split(',').map(function(k){return new RegExp(k, "i")})}}
		if(obj.url){params["entities.urls"]=obj.url}
		if(obj.media){params["entities.media"]=(obj.media.split(",").length==1)?obj.media.split(",")[0]: {"$in": obj.media.split(',').map(function(k){return new RegExp(k, "i")})}}
		if(obj.hasMedia){params["entities.media.0"]={"$exists":true}}
		if(obj.retweeted_id){params["retweeted_id"]=parseInt(obj.retweeted_id)}
		//machine learning
		if(obj.machineLearning){
			if(obj.topic=='flu' || obj.topic=="flu2"){
				params["is_valid"]=true
			}else{
				//obj.machineLearning=false
			}
		}


		//bbox
		if(obj.bbox&&obj.bbox!=""){
			obj.bbox=obj.bbox.split(",").map(function(v,i){return parseFloat(v)});

			if(obj.bbox.length%2==0){
				//bbox length==4 >> rectangel bbox
				if(obj.bbox.length==4){
					var sw=obj.bbox.slice(0,2),
						ne=obj.bbox.slice(2,4),
						nw=[sw[0],ne[1]],
						se=[ne[0],sw[1]];

					/** $box only suppport 2d index
					params["coordinates.coordinates"]={
						"$geoWithin":{"$box":[sw, ne]}
					}
					*/
					//use 2dphere index
					params["coordinates"]={
						"$geoWithin":{"$geometry":{
							"type":"Polygon",
							"coordinates":[[sw, nw, ne, se, sw]]
						}}
					}
				}else{
					//polygon bbox
					var coords=[];
					for(var i=0, len=obj.bbox.length; i<len-2; i+=2){
						coords.push([obj.bbox[i], obj.bbox[i+1]])
					}

					params["coordinates.coordinates"]={
						"$geoWithin":{"$polygon":coords}
					}
				}
			}

		}
		//polygon: lng1, lat1, lng2, lat2, lng3, lat3
		if(obj.polygon&&obj.polygon!=""){
			var polygons=[], num=0
			obj.polygon=obj.polygon.split(',');

			//parse polygon
			for(var i=0, len=obj.polygon.length; i<len; i+=2){
				polygons.push([parseFloat(obj.polygon[i]), parseFloat(obj.polygon[i+1])])
			}

			params["coordinates.coordinates"]={
				"$geoWithin":{
					"$polygon":polygons
				}
			}
		}



		//options
		var options={
			fields: fields
		}
		if(obj.sort){options["sort"]={}; options["sort"][obj.sort]=-1}
		if(obj.limit){options["limit"]=obj.limit}
		if(obj.batchSize){options["batchSize"]=obj.batchSize}


		return {
			params:params,
			getMongodbQueryParams: function(){
				return {params:params, options:options}
			},
			getValue:function(paramName){
				if(obj[paramName]){
					return (isNaN(obj[paramName]))?obj[paramName]:parseFloat(obj[paramName])
				}
			}
		}
}


//get host path
Common.prototype.getHostPath=function(req){
		var host=req.get('host');
		/**
		switch(host){
			case "vision.sdsu.edu:8080":
				host="hdma";
			break;
			case "52.26.133.89:8080":
				host="ec2";
			break;
		}
		*/

		return (host=="vision.sdsu.edu:8080")?"hdma":"ec2"
}


// Porter stemmer in Javascript. Few comments, but it's easy to follow against the rules in the original
// paper, in
//
//  Porter, 1980, An algorithm for suffix stripping, Program, Vol. 14,
//  no. 3, pp 130-137,
//
// see also http://www.tartarus.org/~martin/PorterStemmer

// Release 1 be 'andargor', Jul 2004
// Release 2 (substantially revised) by Christopher McKenzie, Aug 2009
Common.prototype.stemmer=function(w){
		var step2list = {
				"ational" : "ate",
				"tional" : "tion",
				"enci" : "ence",
				"anci" : "ance",
				"izer" : "ize",
				"bli" : "ble",
				"alli" : "al",
				"entli" : "ent",
				"eli" : "e",
				"ousli" : "ous",
				"ization" : "ize",
				"ation" : "ate",
				"ator" : "ate",
				"alism" : "al",
				"iveness" : "ive",
				"fulness" : "ful",
				"ousness" : "ous",
				"aliti" : "al",
				"iviti" : "ive",
				"biliti" : "ble",
				"logi" : "log"
			},

			step3list = {
				"icate" : "ic",
				"ative" : "",
				"alize" : "al",
				"iciti" : "ic",
				"ical" : "ic",
				"ful" : "",
				"ness" : ""
			},

			c = "[^aeiou]",          // consonant
			v = "[aeiouy]",          // vowel
			C = c + "[^aeiouy]*",    // consonant sequence
			V = v + "[aeiou]*",      // vowel sequence

			mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
			meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
			mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
			s_v = "^(" + C + ")?" + v;                   // vowel in stem


			var stem,
				suffix,
				firstch,
				re,
				re2,
				re3,
				re4,
				origword = w;

			if (w.length < 3) { return w; }

			firstch = w.substr(0,1);
			if (firstch == "y") {
				w = firstch.toUpperCase() + w.substr(1);
			}

			// Step 1a
			re = /^(.+?)(ss|i)es$/;
			re2 = /^(.+?)([^s])s$/;

			if (re.test(w)) { w = w.replace(re,"$1$2"); }
			else if (re2.test(w)) {	w = w.replace(re2,"$1$2"); }

			// Step 1b
			re = /^(.+?)eed$/;
			re2 = /^(.+?)(ed|ing)$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				re = new RegExp(mgr0);
				if (re.test(fp[1])) {
					re = /.$/;
					w = w.replace(re,"");
				}
			} else if (re2.test(w)) {
				var fp = re2.exec(w);
				stem = fp[1];
				re2 = new RegExp(s_v);
				if (re2.test(stem)) {
					w = stem;
					re2 = /(at|bl|iz)$/;
					re3 = new RegExp("([^aeiouylsz])\\1$");
					re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
					if (re2.test(w)) {	w = w + "e"; }
					else if (re3.test(w)) { re = /.$/; w = w.replace(re,""); }
					else if (re4.test(w)) { w = w + "e"; }
				}
			}

			// Step 1c
			re = /^(.+?)y$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				stem = fp[1];
				re = new RegExp(s_v);
				if (re.test(stem)) { w = stem + "i"; }
			}

			// Step 2
			re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				stem = fp[1];
				suffix = fp[2];
				re = new RegExp(mgr0);
				if (re.test(stem)) {
					w = stem + step2list[suffix];
				}
			}

			// Step 3
			re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				stem = fp[1];
				suffix = fp[2];
				re = new RegExp(mgr0);
				if (re.test(stem)) {
					w = stem + step3list[suffix];
				}
			}

			// Step 4
			re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
			re2 = /^(.+?)(s|t)(ion)$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				stem = fp[1];
				re = new RegExp(mgr1);
				if (re.test(stem)) {
					w = stem;
				}
			} else if (re2.test(w)) {
				var fp = re2.exec(w);
				stem = fp[1] + fp[2];
				re2 = new RegExp(mgr1);
				if (re2.test(stem)) {
					w = stem;
				}
			}

			// Step 5
			re = /^(.+?)e$/;
			if (re.test(w)) {
				var fp = re.exec(w);
				stem = fp[1];
				re = new RegExp(mgr1);
				re2 = new RegExp(meq1);
				re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
				if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
					w = fp[0];  //need to return the original word not the stem
				}
			}

			re = /ll$/;
			re2 = new RegExp(mgr1);
			if (re.test(w) && re2.test(w)) {
				re = /.$/;
				w = w.replace(re,"");
			}

			// and turn initial Y back to y

			if (firstch == "y") {
				w = firstch.toLowerCase() + w.substr(1);
			}

			return w;

}


//get api scripts
Common.prototype.getAPIScript=function(req){
		//api scripts
		var host=this.getHostPath(req),
			jsPath="/"+host+"/js/api/",
			scripts=[jsPath+"hdma.layer.js", jsPath+"hdma.util.js"];

		return scripts
}



//get text from html tag
Common.prototype.getTextFromHTMLTag=function(linkText, tag) {
		var reg=new RegExp("<"+tag+" [^>]+>([^<]+)<\/"+tag+">")
		return linkText.match(reg)[1];
}


//send mail
Common.prototype.sendMail=function(mailOptions, callback){
		if(!mailOptions){mailOptions={}}
		mailOptions.from=mailOptions.from || "hdmasdsu@gmail.com";
		mailOptions.to=mailOptions.to || "hdmasdsu@gmail.com";
		mailOptions.subject=mailOptions.subject || "test";
		mailOptions.text=mailOptions.text || "test only";
		mailOptions.html=mailOptions.html || "<b>test only</b>";

		var defer=Q.defer();

		if(this._transporter){
			this._trasporter.sendMail(mailOptions, function(err, info){
				if(err){defer.reject(err); return; }

				defer.resolve(info)
			})
		}else{
			defer.reject('no transporter. please call hdma.common.gmailTransporter(xoauth2_options) first');
		}

		return defer.promise.nodeify(callback)

}


//get common folder path
Common.prototype.getCommonFolderPath=function(req, params){
		params=params || {}
		var host=this.getHostPath(req);

		params.hostPath=host;
		params.commonPath=host+"/common";
		params.jsPath=params.commonPath+"/js";
		params.cssPath=params.commonPath+"/css";

		return params;
}


//clean tweet Data
Common.prototype.cleanTweet=function (t, options){
	//options
	options=options || {}
	options.searchInfo=options.searchInfo || {keywords:[], search_areas:[], topics:[]};
	options.matchKeywords=options.matchKeywords || null;

	var mCreatedAt=(function(){
		if(t["timestamp_ms"]){
			return MOMENT(parseInt(t["timestamp_ms"]))
		}else if(t["created_at"]){
			return MOMENT(t["created_at"], "ddd MMM DD HH:mm:ss ZZ YYYY");
		}else{
			return null
		}
	})()


	//created_at >> convert string to date object
	if(mCreatedAt){
		var localZone=-8,
			mCreatedAtLocal=MOMENT(mCreatedAt.valueOf()+(localZone*60*60*1000));

		t['created_at']=mCreatedAt.toDate();

		//created_at_local
		t['created_at_local']=mCreatedAtLocal.toDate();

		//source
		t['source_clean']=this.getTextFromHTMLTag(t['source'],'a');

		//match keywords since 3/3/2015
		if(options.matchKeywords&&options.matchKeywords.length>0){
			var keywords=options.searchInfo.keywords=[];

			//var matchID=matchKeywords.indexOf(t.text);
			var matchTexts=(t.text)?t.text.toLowerCase():null;//.split(" ");
			if(matchTexts){
				options.matchKeywords.forEach(function(v,i){
					if(matchTexts.indexOf(v)!=-1){
						keywords.push(v)
					}
				});
			}
		}


		t['search_info']=options.searchInfo
	}


	return t
}





//canvasImage
var canvasImage=Common.prototype.canvasImage=function(options){
		if(CANVAS && HEATMAP){
			options=options || {}
			this.type=options.type=options.type || "HEATMAP";
			this.canvasWidth=options.canvasWidth=options.canvasWidth || 0;
			this.canvasHeight=options.canvasHeight=options.canvasHeight || 0;
			this.heatmapRadius=options.heatmapRadius=options.heatmapRadius || 10;
			this.bbox=options.bbox=options.bbox || null;
			this.rgba=options.rgba=options.rgba || [255,0,0,255];

			//recalculate width and height by bbox
			if(this.canvasWidth==0 || this.canvasHeight==0){
				var bbox=this.bbox,
						ratio=Math.abs(bbox[2]-bbox[0]) / Math.abs(bbox[3]-bbox[1]);   //width / height
				this.canvasHeight=256;
				this.canvasWidth=Math.round(this.canvasHeight * ratio);
			}

			//heat obj
			this.canvas=new CANVAS(this.canvasWidth, this.canvasHeight);
			this.heat=new HEATMAP(this.canvas,{radius:this.heatmapRadius});
			//this.heat=new HEATMAP(this.canvasWidth, this.canvasHeight,{radius:this.heatmapRadius});
			//this.canvas=this.heat.canvas;
			this.ctx=this.canvas.getContext("2d");
			this.canvasData=this.ctx.getImageData(0,0,this.canvasWidth, this.canvasHeight);

			//add image
			this.markerIcon=null;
			if(this.type.toUpperCase()=='MARKER'){
				//here we need to use the same canvas from Heatmap. we cannot create it from CANVAS (var img=new CANVAS.Image)
				//otherwise, there is an error showing that "canvas or image is expected"
				//thus,
				// 1)we need to customize the index.js in the heatmap folder in the node_module to export Image class
				// OR 2) just rename or delete canvas folder in the heatmap node_module to make sure it read the canvas in the global.
				var img=new CANVAS.Image;
				//var img=new HEATMAP.Image;
				img.src=FS.readFileSync("./public/common/js/leaflet/images/marker-icon.png");
				/**
				fs.readFile("public/common/js/leaflet/images/marker-icon.png", function(e, data){
					console.log(e)
					console.log(data)
				})
				*/
				this.markerIcon=img;
			}

			//data
			this.latlngs=[];
		}
}
//prototypes
canvasImage.prototype.lnglatToPixel= function(lng, lat){
			var bbox=this.bbox,
					width=this.canvasWidth,
					height=this.canvasHeight;


			if(bbox&&bbox instanceof Array&&bbox.length==4){
				var original_lng=bbox[0],
						original_lat=bbox[3],
						lngSpan=Math.abs(bbox[2] - bbox[0]),
						latSpan=Math.abs(bbox[3] - bbox[1]);

				//return [(Math.abs(lng - original_lng) / lngSpan) * width, (Math.abs(original_lat - lat) / latSpan) * height]

				var x = (lng - original_lng) * (width / lngSpan);
				lat = lat * Math.PI / 180;
				var worldMapWidth = ((width / lngSpan) * 360) / (2 * Math.PI);
				var latBottomDegree= bbox[1] *Math.PI/180;
				var mapOffsetY = (worldMapWidth / 2 * Math.log((1 + Math.sin(latBottomDegree)) / (1 - Math.sin(latBottomDegree))));
				var y = height - ((worldMapWidth / 2 * Math.log((1 + Math.sin(lat)) / (1 - Math.sin(lat)))) - mapOffsetY);

				return [Math.round(x), Math.round(y)]
			}
}
canvasImage.prototype.addLatLng= function(lat, lng){
			var latlngs=this.latlngs,
					type=this.type,
					xy=this.lnglatToPixel(lng, lat),
					index=0,
					rgba=this.rgba,
					width=this.canvasWidth,
					ctx=this.ctx,
					markerIcon=this.markerIcon,
					canvasData=this.canvasData;


			if(xy&&xy.length==2){
				//HEATMAP
				if(type=='HEATMAP'){
					this.heat.addPoint(xy[0], xy[1])
				}

				//point
				if(type=='POINT'){
					index=(xy[0] + xy[1]*width)*4;
					rgba.forEach(function(c,j){
						canvasData.data[index+j]=c;
					})
				}

				//MARKER //not finished!
				if(type=='MARKER'){
					//ctx.font="40px FontAwesome";
					//ctx.fillText("\uf000", xy[0], xy[1]);
					//console.log(markerIcon, markerIcon.width)
					ctx.drawImage(markerIcon, xy[0], xy[1], markerIcon.width/2, markerIcon.height/2)

				}

				latlngs.push([lat,lng])
			}
}
canvasImage.prototype.draw=function(){
	var type=this.type;

	switch(type){
		case "HEATMAP":
			this.heat.draw()
		break;
		case "POINT":
			this.ctx.putImageData(this.canvasData, 0, 0 )
		break;
		case "MARKER":

		break;
	}
}




//extend Array extend
Array.prototype.extend = function (other_array) {
    /* you should include a test to check whether other_array really is an array */
    other_array.forEach(function(v) {this.push(v)}, this);
}



//overwrite MetaInspector
if(METAINSPECTOR){
	METAINSPECTOR.prototype.fetch = function(){
		var _this = this;
		var totalChunks = 0;

		var r = REQUEST({uri : this.url, followAllRedirects: true, followRedirect:true, method: "HEAD" }, function(error, response, body){
			if(response){
				//only focus on html/text. Otherwise, it will make "max-stack size exceeded" error!!!!!
				var contentType=response.headers["content-type"];

				if(!error && response.statusCode === 200 && contentType && (contentType.indexOf("text/html")!=-1)){
					_this.document = body;
					_this.parsedDocument = $.load(body);
					_this.response = response;

					_this.initAllProperties();

					_this.emit("fetch");
				}
				else{
					_this.emit("error", error, contentType);
				}
			}
		});

		if(_this.options.limit){
			r.on('data', function(chunk){
				totalChunks += chunk.length;
				if(totalChunks > _this.options.limit){
					_this.emit("limit");
					r.abort();
				}
			});
		}
	};

}
