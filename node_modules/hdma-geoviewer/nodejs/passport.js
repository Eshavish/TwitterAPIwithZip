var PASSPORT_TWITTER=require("passport-twitter").Strategy,
    HDMA=require("./api/hdma"),
    CONFIG=require("./config/config"),
    MOMENT=require("moment"),
    QUERYSTRING=require("querystring"),
    ipAddress=(function(){
      var ip=null
      require("os").networkInterfaces()["Local Area Connection"].forEach(function(obj,i){
        if(obj.family=='IPv4'&&obj.address.split(".").length==4){
          ip=obj.address
        }
      })
      return ip
    })(),
    serverName=(ipAddress=='130.191.118.59')?"vision":"ec2",
    app={
      twitterToken: CONFIG.twitterTokens[serverName]["volunteer"]
    };



//exports
module.exports=function(passport){


  //twitter
  passport.use(new PASSPORT_TWITTER({
    consumerKey:app.twitterToken.consumer_key,
    consumerSecret:app.twitterToken.consumer_secret,
    callbackURL:"http://vision.sdsu.edu/hdma/auth/twitter/callback"
  }, function(token, tokenSecret, profile, done){
      // To keep the example simple, the user's Twitter profile is returned to
      // represent the logged-in user.  In a typical application, you would want
      // to associate the Twitter account with a user record in your database,
      // and return that user instead.
      profile.tokens={
        token:token,
        tokenSecret:tokenSecret
      }
      return done(null, profile);
  }))


  //return obj
  return new Output(passport)
}


//Output class
var Output=function(passport){
  this.passport=passport;
}


//routes
Output.prototype.routes=function(app, options){
  options=options || {}
  options.authPath=options.authPath || "/auth/:type";
  options.callbackPath=options.callbackPath || "/auth/:type/callback"
  options.successRedirect=options.successRedirect || "/auth/:type/success";
  options.failureRedirect=options.failureRedirect || "/auth/:type/failure";

  var that=this,
      passport=this.passport;


  //auth
  app.get("/auth/:type", function(req,res){
    var type=req.params.type,
        isSupported=that.verify(type);

    //save returnTo path from tha webpage which called auth/:type
    req.session.returnTo=null;
    if(req.query&&req.query.returnTo){
      req.session.returnTo=req.query.returnTo;
    }


    if(isSupported){
      passport.authenticate(type)(req, res);
    }else{
      res.json({error:type+" is not suppported!"})
    }
  });


  //callback
  app.get("/auth/:type/callback", function(req, res, next){
    var type=req.params.type,
        isSupported=that.verify(type),
        host=HDMA.common.getHostPath(req),
        query_string=QUERYSTRING.stringify(req.query);


    //handle returnTo
    options.successRedirect="/"+host+"/auth/"+type+"/success";
    options.failureRedirect="/"+host+"/auth/"+type+"/failure";
    var returnTo=req.session.returnTo
    if(returnTo&&returnTo!=""){
      options.successRedirect=options.failureRedirect="/"+host+returnTo;

      //if returnURL is started from '//' >> return to the specfic website
      if(returnTo.search(/^\/\//)!=-1){
        options.successRedirect=options.failureRedirect=returnTo
      }

      console.log(returnTo)
      req.session.returnTo=null
    }


    if(isSupported){
      //customize authenticate callback url
      passport.authenticate(type, function(err, user, info){
        var successRedirect=options.successRedirect, //+"?"+query_string,
            failureRedirect=options.failureRedirect; //+"?"+query_string;

        query_string=QUERYSTRING.stringify({user_id:user.id, type:type})

        if (err) { return next(err); }
        if (!user) { return res.redirect(failureRedirect); }


        req.logIn(user, {session:true}, function(err){
          if (err) { return next(err); }
          return res.redirect(successRedirect+"?"+query_string);
        })
      })(req, res, next);

    }else{
      res.json({error:type+" is not suppported!"})
    }
  });



  //failure
  app.get("/auth/:type/failure", function(req, res){
    var type=req.params.type,
        out={error: "authenticate failure!"};

        if(req.query){out["query"]=req.query}
        if(req.user){out["userid"]=(type=='twitter')?req.user.id:req.user}

        res.render('oauth/failure', HDMA.common.getCommonFolderPath(req, {oauth_callback:JSON.stringify(out)}))
  })

  //success
  app.get("/auth/:type/success", function(req, res){
    var type=req.params.type,
        out={msg:"authenticate success"};

    if(req.query){out["query"]=req.query}
    if(req.user){out["userid"]=(type=='twitter')?req.user.id:req.user}

    res.render('oauth/success', HDMA.common.getCommonFolderPath(req, {oauth_callback:JSON.stringify(out)}))
  })

}


//varify social media
Output.prototype.verify=function(type){
  var output=false,
      supports=["TWITTER"];

  if(supports.indexOf(type.toUpperCase())!=-1){
    output=true;
  }

  return output
}

//set MONGODB
Output.prototype.setDB=function(mongodb){
  if(mongodb){
    var passport=this.passport;

    // Passport session setup.
    //   To support persistent login sessions, Passport needs to be able to
    //   serialize users into and deserialize users out of the session.  Typically,
    //   this will be as simple as storing the user ID when serializing, and finding
    //   the user by ID when deserializing.  However, since this example does not
    //   have a database of user records, the complete Twitter profile is serialized
    //   and deserialized.
    passport.serializeUser(function(user, done) {
      console.log("User, "+user.username+", is login! id='"+user.id+" is saved in session!")

      //save into MONGODB
      HDMA.mongodb.query(mongodb, "userProfile", {id:user.id}, {}, function(err, results){
        //update login times
  			user.login_times=[];
        var exists=(results&&results.length==1)?true:false;

        if(exists){
          user.login_times=results[0].login_times;
        }
        user.login_times.push(MOMENT().toDate())


  			HDMA.mongodb.update(mongodb, "userProfile", {id:user.id},  user, {upsert:true}, function(err, r){})
      });


      //only save user.id in the session
      done(null, user.id);
    });


    passport.deserializeUser(function(id, done) {
      //we need to query mongodb to retrieve user data back by id
      if(mongodb){
        HDMA.mongodb.query(mongodb, "userProfile", {id:id}, {}, function(err, results){
          var result=(results&&results.length==1)?results[0]:null;

          done(err, result)
        })
      }
    });
  }

}
